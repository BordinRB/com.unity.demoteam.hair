#pragma kernel Main

#pragma multi_compile __ STAGING_COMPRESSION
// 0 == staging data full precision
// 1 == staging data compressed

#pragma multi_compile __ HAIR_VERTEX_ID_LINES HAIR_VERTEX_ID_STRIPS HAIR_VERTEX_ID_TUBES
// *_LINES == render as line segments
// *_STRIPS == render as view facing strips

#pragma multi_compile HAIR_VERTEX_SRC_SOLVER HAIR_VERTEX_SRC_STAGING
// *_SOLVER == source vertex from solver data
// *_STAGING == source vertex data from staging data

//----------
// includes
#pragma enable_d3d11_debug_symbols

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"

#include "HairVertex.hlsl"

ByteAddressBuffer   _VertexBufferUV;
RWByteAddressBuffer _VertexBufferP;
RWByteAddressBuffer _VertexBufferT;

float2 LoadVertexUV(uint vertexID)
{
    uint  uv = _VertexBufferUV.Load(vertexID << 2);
    float lo = UnpackUIntToFloat(uv, 0u,  16u);
    float hi = UnpackUIntToFloat(uv, 16u, 16u);
    return float2(lo, hi);
}

[numthreads(1024, 1, 1)]
void Main(uint3 dispatchID : SV_DispatchThreadID)
{
    uint   vertexID = dispatchID.x;
    float2 vertexUV = LoadVertexUV(vertexID);

    HairVertex v = GetHairVertex(vertexID, vertexUV, 0, 0, 0);

    // temp hack: un-do some translations
    const float3 x = TransformObjectToWorld(v.positionOS);
    const float3 y = GetAbsolutePositionWS(x);
    const float3 z = TransformWorldToObject(y);
    
    _VertexBufferP.Store3((12u * vertexID), asuint(z));
    _VertexBufferT.Store3((12u * vertexID), asuint(v.tangentOS));
}