#pragma kernel KVolumeClear
#pragma kernel KVolumeSplat
#pragma kernel KVolumeSplatDensity
#pragma kernel KVolumeSplatVelocityX
#pragma kernel KVolumeSplatVelocityY
#pragma kernel KVolumeSplatVelocityZ
#pragma kernel KVolumeResolve
#pragma kernel KVolumeResolveFromRasterization
#pragma kernel KVolumeGradient
#pragma kernel KVolumeDivergence
#pragma kernel KVolumePressureEOS
#pragma kernel KVolumePressureSolve
#pragma kernel KVolumePressureGradient

#define HAIRSIM_WRITEABLE_VOLUMEDATA 1

#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverData.hlsl"
#include "HairSimComputeVolumeData.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

#define PARTICLE_NUM_X 64
#define PARTICLE_NUM_Y 1
#define PARTICLE_NUM_Z 1

#define VOLUME_NUM_X 4
#define VOLUME_NUM_Y 4
#define VOLUME_NUM_Z 4

#define VOLUME_AIR_CELL_ZERO_PRESSURE 1
#define VOLUME_AIR_CELL_ZERO_DIVERGENCE 0

#define VOLUME_DIFF_STEP_IS_ONE 0// TODO remove

#if VOLUME_DIFF_STEP_IS_ONE
#define VOLUME_DIFF_STEP (1.0)
#else
#define VOLUME_DIFF_STEP (VolumeWorldCellSize())
#endif

//---------
// utility

void InterlockedAddTrilinear(RWTexture3D<int> volume, uint3 idx0, float value, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedAdd(volume[idx0 + h.yyy], (int)(value * w0.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xyy], (int)(value * w1.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yxy], (int)(value * w0.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xxy], (int)(value * w1.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yyx], (int)(value * w0.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xyx], (int)(value * w1.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.yxx], (int)(value * w0.x * w1.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xxx], (int)(value * w1.x * w1.y * w1.z));
}

void InterlockedAddParticleContribution(uint i, float value, RWTexture3D<int> volume)
{
#if SPLAT_TRILINEAR
	const float3 localPos = VolumeWorldToLocal(_ParticlePosition[i].xyz) - 0.5;// subtract offset to cell center
	const float3 localPosFloor = floor(localPos);

	const uint3 cellIdx0 = localPosFloor;
	const float3 cellPos = localPos - localPosFloor;

	const float3 w0 = 1.0 - cellPos;
	const float3 w1 = cellPos;

	InterlockedAddTrilinear(volume, cellIdx0, value / SPLAT_PRECISION, w0, w1);
#else
	InterlockedAdd(volume[VolumeWorldToIndex(_ParticlePosition[i].xyz)], (int)(value / SPLAT_PRECISION));
#endif
}

//---------
// kernels

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_AccuDensity[worldIdx] = 0;
	_AccuVelocityX[worldIdx] = 0;
	_AccuVelocityY[worldIdx] = 0;
	_AccuVelocityZ[worldIdx] = 0;
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplat(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	//TODO remap and pack according to max velocity within volume
	//float3 velocityStepLimit = _VolumeWorldMax - _VolumeWorldMin;
	//float3 velocityStep = clamp(_ParticleVelocity[worldIdx.x].xyz * _DT, -velocityStepLimit, velocityStepLimit);

	InterlockedAddParticleContribution(worldIdx.x, 1.0, _AccuDensity);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _AccuVelocityX);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _AccuVelocityY);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _AccuVelocityZ);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, 1.0, _AccuDensity);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityX(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _AccuVelocityX);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityY(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _AccuVelocityY);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityZ(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _AccuVelocityZ);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeResolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint n = _AccuDensity[worldIdx];

	//const float cell_fill = _StrandParticleVolume / (1e+9 * VolumeWorldCellVolume());
	//const float cell_capacity = (1e+9 * VolumeWorldCellVolume()) / _StrandParticleVolume;

	const float rho_unscaled = n * SPLAT_PRECISION;
	const float rho = rho_unscaled;
	//const float rho = rho_unscaled * cell_fill;

	_VolumeDensity[worldIdx] = rho;

	_VolumeVelocity[worldIdx] = float4(float3(
		_AccuVelocityX[worldIdx],
		_AccuVelocityY[worldIdx],
		_AccuVelocityZ[worldIdx]) / (float)max(1, n),
		rho_unscaled);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeResolveFromRasterization(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const float4 splat = _VolumeVelocity[worldIdx];
	{
		_VolumeDensity[worldIdx] = splat.w;

		if (splat.w > 0.0)
			_VolumeVelocity[worldIdx] = float4(splat.xyz / splat.w, splat.w);
		else
			_VolumeVelocity[worldIdx] = 0.0;
	}
}

#if LDS_GRADIENT
groupshared int gs_density[VOLUME_NUM_X * VOLUME_NUM_Y * VOLUME_NUM_Z];
#endif

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
#if !LDS_GRADIENT

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.x);
#else
	const float3 h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.xyz);
#endif

	const float3 diff = float3(
		_VolumeDensity[worldIdx + worldIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
		_VolumeDensity[worldIdx + worldIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
		_VolumeDensity[worldIdx + worldIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
		) * h_inv;

	_VolumeDensityGrad[worldIdx] = diff;

#else// if (LDS_GRADIENT)

	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint threadIdxStrideX = 1;
	const uint threadIdxStrideY = VOLUME_NUM_X;
	const uint threadIdxStrideZ = VOLUME_NUM_X * VOLUME_NUM_Y;
	/*
	SV_GroupIndex =
		SV_GroupThreadID.z*dimx*dimy +
		SV_GroupThreadID.y*dimx +
		SV_GroupThreadID.x
	*/

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z) - 1;

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.x);
#else
	const float3 h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.xyz);
#endif

	const bool lowerBoundary = any(localIdx == localLowerIdx);
	const bool upperBoundary = any(localIdx == localUpperIdx);

	if (lowerBoundary || upperBoundary)
	{
		if (lowerBoundary && upperBoundary)
		{
			const float3 diff = float3(
				_VolumeDensity[worldIdx + worldIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
				_VolumeDensity[worldIdx + worldIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
				_VolumeDensity[worldIdx + worldIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
				) * h_inv;

			_VolumeDensityGrad[worldIdx] = diff;
		}
		else if (lowerBoundary)
		{
			const float3 diff = float3(
				gs_density[threadIdx + threadIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
				gs_density[threadIdx + threadIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
				gs_density[threadIdx + threadIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
				) * h_inv;

			_VolumeDensityGrad[worldIdx] = diff;
		}
		else// upperBoundary
		{
			const float3 diff = float3(
				_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
				_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
				_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
				) * h_inv;

			_VolumeDensityGrad[worldIdx] = diff;
		}
	}
	else
	{
		const float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) * h_inv;

		_VolumeDensityGrad[worldIdx] = diff;
	}

#endif// (LDS_GRADIENT)
}

#if LDS_GRADIENT
[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradientForwardDiff(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z) - 1;

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.x);
#else
	const float3 h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.xyz);
#endif

	if (any(localIdx == localUpperIdx))
	{
		const uint3 worldIdxStrideX = uint3(1, 0, 0);
		const uint3 worldIdxStrideY = uint3(0, 1, 0);
		const uint3 worldIdxStrideZ = uint3(0, 0, 1);

		const float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx]
			) * h_inv;

		_VolumeDensityGrad[worldIdx] = diff;
	}
	else
	{
		const uint threadIdxStrideX = 1;
		const uint threadIdxStrideY = VOLUME_NUM_X;
		const uint threadIdxStrideZ = VOLUME_NUM_X * VOLUME_NUM_Y;
		/*
		SV_GroupIndex =
			SV_GroupThreadID.z*dimx*dimy +
			SV_GroupThreadID.y*dimx +
			SV_GroupThreadID.x
		*/

		const float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx]
			) * h_inv;

		_VolumeDensityGrad[worldIdx] = diff;
	}
}
#endif// (LDS_GRADIENT)

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeDivergence(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_AIR_CELL_ZERO_DIVERGENCE
	const float d_xm = _VolumeDensity[worldIdx - worldIdxStrideX];
	const float d_ym = _VolumeDensity[worldIdx - worldIdxStrideY];
	const float d_zm = _VolumeDensity[worldIdx - worldIdxStrideZ];

	const float d_xp = _VolumeDensity[worldIdx + worldIdxStrideX];
	const float d_yp = _VolumeDensity[worldIdx + worldIdxStrideY];
	const float d_zp = _VolumeDensity[worldIdx + worldIdxStrideZ];

	const bool air_x = (d_xm == 0.0) || (d_xp == 0.0);
	const bool air_y = (d_ym == 0.0) || (d_yp == 0.0);
	const bool air_z = (d_zm == 0.0) || (d_zp == 0.0);

	const float vx_xm = air_x ? 0.0 : _VolumeVelocity[worldIdx - worldIdxStrideX].x;
	const float vy_ym = air_y ? 0.0 : _VolumeVelocity[worldIdx - worldIdxStrideY].y;
	const float vz_zm = air_z ? 0.0 : _VolumeVelocity[worldIdx - worldIdxStrideZ].z;

	const float vx_xp = air_x ? 0.0 : _VolumeVelocity[worldIdx + worldIdxStrideX].x;
	const float vy_yp = air_y ? 0.0 : _VolumeVelocity[worldIdx + worldIdxStrideY].y;
	const float vz_zp = air_z ? 0.0 : _VolumeVelocity[worldIdx + worldIdxStrideZ].z;
#else
	const float vx_xm = _VolumeVelocity[worldIdx - worldIdxStrideX].x;
	const float vy_ym = _VolumeVelocity[worldIdx - worldIdxStrideY].y;
	const float vz_zm = _VolumeVelocity[worldIdx - worldIdxStrideZ].z;

	const float vx_xp = _VolumeVelocity[worldIdx + worldIdxStrideX].x;
	const float vy_yp = _VolumeVelocity[worldIdx + worldIdxStrideY].y;
	const float vz_zp = _VolumeVelocity[worldIdx + worldIdxStrideZ].z;
#endif

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.x);
	const float div = float(
		(vx_xp - vx_xm) +
		(vy_yp - vy_ym) +
		(vz_zp - vz_zm)) * h_inv;
#else
	const float3 h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.xyz);
	const float div = float(
		(vx_xp - vx_xm) * h_inv.x +
		(vy_yp - vy_ym) * h_inv.y +
		(vz_zp - vz_zm) * h_inv.z);
#endif

	const float rho = _VolumeDensity[worldIdx];
	const float rho0 = 1.0 / pow(_StrandParticleContrib, 3.0);

#if VOLUME_DIFF_STEP_IS_ONE
	_VolumeDivergence[worldIdx] = div - (rho / rho0 - 1.0) * (_Repulsion) * (VolumeWorldCellSize().x);
#else
	_VolumeDivergence[worldIdx] = div - (rho / rho0 - 1.0) * (_Repulsion);
#endif

	//OLD
	//_VolumeDivergence[worldIdx] = div + (rho0 - rho);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureEOS(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const float rho = _VolumeDensity[worldIdx];
	const float rho0 = 1.0 / pow(_StrandParticleContrib, 3.0);

#if VOLUME_AIR_CELL_ZERO_PRESSURE
	if (rho == 0.0)
	{
		_VolumePressure[worldIdx] = 0.0;
		return;
	}
#endif

#if VOLUME_DIFF_STEP_IS_ONE
	_VolumePressure[worldIdx] = (rho / rho0 - 1.0) * (_Repulsion);
#else
	_VolumePressure[worldIdx] = (rho / rho0 - 1.0) * (_Repulsion * VolumeWorldCellSize().x * VolumeWorldCellSize().x);
#endif

	//OLD
	//if (rho != 0.0)
	//	_VolumePressure[worldIdx] = -(rho0 - rho) * (VolumeWorldCellVolume() / _DT);
	//else
	//	_VolumePressure[worldIdx] = 0.0;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureSolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	// solve poisson equation for pressure using central differences
	// https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html

	const float p_xm = _VolumePressureIn[worldIdx - worldIdxStrideX];
	const float p_ym = _VolumePressureIn[worldIdx - worldIdxStrideY];
	const float p_zm = _VolumePressureIn[worldIdx - worldIdxStrideZ];

	const float p_xp = _VolumePressureIn[worldIdx + worldIdxStrideX];
	const float p_yp = _VolumePressureIn[worldIdx + worldIdxStrideY];
	const float p_zp = _VolumePressureIn[worldIdx + worldIdxStrideZ];

	//const float p_in = _VolumePressureIn[worldIdx];

	const float b = _VolumeDivergence[worldIdx];
	const float w = 1.0;// SOR factor [1..2]

#if VOLUME_SQUARE_CELLS
	const float h = 1.0 * VOLUME_DIFF_STEP.x;
	const float a = -(h * h);

	const float pressure =
		//(1.0 - w) * p_in +
		(w / 6.0) * float(
			p_xm + p_xp +
			p_ym + p_yp +
			p_zm + p_zp +
			a * b);
#else
	const float3 h = 1.0 * VOLUME_DIFF_STEP.xyz;
	const float3 a = -(h * h) / 3.0;

	const float pressure =
		//(1.0 - w) * p_in +
		(w / 6.0) * float(
			(p_xm + p_xp + a.x * b) + 
			(p_ym + p_yp + a.y * b) +
			(p_zm + p_zp + a.z * b));
#endif

	_VolumePressure[worldIdx] = pressure;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.x);
#else
	const float3 h_inv = 1.0 / (2.0 * VOLUME_DIFF_STEP.xyz);
#endif

	const float3 diff = float3(
		_VolumePressure[worldIdx + worldIdxStrideX] - _VolumePressure[worldIdx - worldIdxStrideX],
		_VolumePressure[worldIdx + worldIdxStrideY] - _VolumePressure[worldIdx - worldIdxStrideY],
		_VolumePressure[worldIdx + worldIdxStrideZ] - _VolumePressure[worldIdx - worldIdxStrideZ]
		) * h_inv;

	_VolumePressureGrad[worldIdx] = diff;
}
