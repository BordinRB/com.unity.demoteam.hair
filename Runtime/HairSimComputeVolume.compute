#pragma kernel KVolumeClear
#pragma kernel KVolumeDensity
#pragma kernel KVolumeGradient

//#include "HairSimComputeConfig.hlsl"
#define DENSITY_SCALE 4096.0
#define DENSITY_TRILINEAR 1

StructuredBuffer<float4> _ParticlePosition;
StructuredBuffer<float4> _ParticleVelocity;

float3 _VolumeCells;
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;
/*
    _VolumeCells = (4, 4, 4)

              +---+---+---Q
         +---+---+---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+
    P---+---+---+

    _VolumeWorldMin = P
    _VolumeWorldMax = Q
*/

RWTexture3D<int> _VolumeDensity;
RWTexture3D<int> _VolumeVelocityX;
RWTexture3D<int> _VolumeVelocityY;
RWTexture3D<int> _VolumeVelocityZ;
RWTexture3D<float3> _VolumeGradient;

float3 ParticleVolumePosition(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 worldPosClamped = clamp(worldPos, _VolumeWorldMin, _VolumeWorldMax);
	float3 localPos = (worldPosClamped - _VolumeWorldMin) * ((_VolumeCells - 1) / (_VolumeWorldMax - _VolumeWorldMin));
	return localPos;
}

uint3 ParticleVolumeIndex(uint i)
{
	float3 localPos = ParticleVolumePosition(i);
	float3 localPosQuantized = round(localPos);
	return localPosQuantized;
}

#define CLEAR_WIDTH 8
#define CLEAR_NUM_X CLEAR_WIDTH
#define CLEAR_NUM_Y CLEAR_WIDTH
#define CLEAR_NUM_Z CLEAR_WIDTH

[numthreads(CLEAR_NUM_X, CLEAR_NUM_Y, CLEAR_NUM_Z)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeDensity[worldIdx] = 0;
	_VolumeVelocityX[worldIdx] = 0;
	_VolumeVelocityY[worldIdx] = 0;
	_VolumeVelocityZ[worldIdx] = 0;
}

void InterlockedAddTrilinear(RWTexture3D<int> volume, uint3 idx0, float value, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedAdd(volume[idx0 + h.yyy], (int)(value * w0.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xyy], (int)(value * w1.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yxy], (int)(value * w0.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xxy], (int)(value * w1.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yyx], (int)(value * w0.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xyx], (int)(value * w1.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.yxx], (int)(value * w0.x * w1.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xxx], (int)(value * w1.x * w1.y * w1.z));
}

[numthreads(64, 1, 1)]
void KVolumeDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
#if DENSITY_TRILINEAR

	float3 velocity = _ParticleVelocity[worldIdx.x].xyz;
	float3 volumePos = ParticleVolumePosition(worldIdx.x);
	float3 volumePosFloor = floor(volumePos);

	uint3 cellIdx0 = volumePosFloor;
	float3 cellPos = volumePos - volumePosFloor;
	
	float3 w0 = 1.0 - cellPos;
	float3 w1 = cellPos;

	InterlockedAddTrilinear(_VolumeDensity, cellIdx0, DENSITY_SCALE, w0, w1);
	InterlockedAddTrilinear(_VolumeVelocityX, cellIdx0, DENSITY_SCALE * velocity.x, w0, w1);
	InterlockedAddTrilinear(_VolumeVelocityY, cellIdx0, DENSITY_SCALE * velocity.y, w0, w1);
	InterlockedAddTrilinear(_VolumeVelocityZ, cellIdx0, DENSITY_SCALE * velocity.z, w0, w1);

#else

	float3 velocity = _ParticleVelocity[worldIdx.x].xyz;
	uint3 volumeIdx = ParticleVolumeIndex(worldIdx.x);

	InterlockedAdd(_VolumeDensity[volumeIdx], DENSITY_SCALE);
	InterlockedAdd(_VolumeVelocityX[volumeIdx], (int)(DENSITY_SCALE * velocity.x));
	InterlockedAdd(_VolumeVelocityY[volumeIdx], (int)(DENSITY_SCALE * velocity.y));
	InterlockedAdd(_VolumeVelocityZ[volumeIdx], (int)(DENSITY_SCALE * velocity.z));

#endif
}

#define GRADIENT_WIDTH 4
#define GRADIENT_NUM_X GRADIENT_WIDTH
#define GRADIENT_NUM_Y GRADIENT_WIDTH
#define GRADIENT_NUM_Z GRADIENT_WIDTH

groupshared int gs_density[GRADIENT_NUM_X * GRADIENT_NUM_Y * GRADIENT_NUM_Z];

[numthreads(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z)]
void KVolumeGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint threadIdxStrideX = 1;
	const uint threadIdxStrideY = GRADIENT_NUM_X;
	const uint threadIdxStrideZ = GRADIENT_NUM_X * GRADIENT_NUM_Y;
	/*
	SV_GroupIndex =
		SV_GroupThreadID.z*dimx*dimy +
		SV_GroupThreadID.y*dimx +
		SV_GroupThreadID.x
	*/

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z) - 1;

	const float k = 1.0 / (2.0 * DENSITY_SCALE);

	if (any(localIdx == localLowerIdx))
	{
		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
	else if (any(localIdx == localUpperIdx))
	{
		float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
	else
	{
		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
}

[numthreads(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z)]
void KVolumeGradientForwardDiff(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z) - 1;

	const float k = 1.0 / DENSITY_SCALE;

	if (any(localIdx == localUpperIdx))
	{
		const uint3 worldIdxStrideX = uint3(1, 0, 0);
		const uint3 worldIdxStrideY = uint3(0, 1, 0);
		const uint3 worldIdxStrideZ = uint3(0, 0, 1);

		float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
	else
	{
		const uint threadIdxStrideX = 1;
		const uint threadIdxStrideY = GRADIENT_NUM_X;
		const uint threadIdxStrideZ = GRADIENT_NUM_X * GRADIENT_NUM_Y;
		/*
		SV_GroupIndex =
			SV_GroupThreadID.z*dimx*dimy +
			SV_GroupThreadID.y*dimx +
			SV_GroupThreadID.x
		*/

		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
}
