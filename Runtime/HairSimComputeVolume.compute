#pragma kernel KVolumeClear
#pragma kernel KVolumeSplat
#pragma kernel KVolumeSplatDensity
#pragma kernel KVolumeSplatVelocityX
#pragma kernel KVolumeSplatVelocityY
#pragma kernel KVolumeSplatVelocityZ
#pragma kernel KVolumeResolve
#pragma kernel KVolumeResolveFromRasterization
#pragma kernel KVolumeGradient
#pragma kernel KVolumeDivergence
#pragma kernel KVolumePressureEOS
#pragma kernel KVolumePressureSolve
#pragma kernel KVolumePressureGradient

#define HAIRSIM_WRITEABLE_VOLUMEDATA 1

#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverData.hlsl"
#include "HairSimComputeVolumeData.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

#define PARTICLE_NUM_X 64
#define PARTICLE_NUM_Y 1
#define PARTICLE_NUM_Z 1

#define VOLUME_NUM_X 4
#define VOLUME_NUM_Y 4
#define VOLUME_NUM_Z 4

#define VOLUME_AIR_CELL_ZERO_PRESSURE 0
#define VOLUME_AIR_CELL_ZERO_PRESSURE_GRAD 0
#define VOLUME_AIR_CELL_ZERO_SOURCE_TERM 0
#define VOLUME_VOF 0
#define VOLUME_GHOST 0

//---------
// utility

void InterlockedAddTrilinear(RWTexture3D<int> volume, uint3 idx0, float value, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedAdd(volume[idx0 + h.yyy], (int)(value * w0.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xyy], (int)(value * w1.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yxy], (int)(value * w0.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xxy], (int)(value * w1.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yyx], (int)(value * w0.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xyx], (int)(value * w1.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.yxx], (int)(value * w0.x * w1.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xxx], (int)(value * w1.x * w1.y * w1.z));
}

void InterlockedAddParticleContribution(uint i, float value, RWTexture3D<int> volume)
{
#if SPLAT_TRILINEAR
	const float3 localPos = VolumeWorldToLocal(_ParticlePosition[i].xyz) - 0.5;// subtract offset to cell center
	const float3 localPosFloor = floor(localPos);

	const uint3 cellIdx0 = localPosFloor;
	const float3 cellPos = localPos - localPosFloor;

	const float3 w0 = 1.0 - cellPos;
	const float3 w1 = cellPos;

	InterlockedAddTrilinear(volume, cellIdx0, value / SPLAT_PRECISION, w0, w1);
#else
	InterlockedAdd(volume[VolumeWorldToIndex(_ParticlePosition[i].xyz)], (int)(value / SPLAT_PRECISION));
#endif
}

bool GhostPressureCell(uint3 worldIdx)
{
	if (_VolumeDensity[worldIdx] == 0)
		return true;
	else
		return false;
}

float GhostPressure(uint3 worldIdx, float pressurePivot, float pressureOther)
{
	if (GhostPressureCell(worldIdx))
	{
		if (pressureOther > pressurePivot)
			return -(pressureOther - pressurePivot);
		else
			return -pressurePivot;
	}
	else
	{
		return _VolumePressure[worldIdx];
	}
}

//----------------
// kernels: clear

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_AccuDensity[worldIdx] = 0;
	_AccuVelocityX[worldIdx] = 0;
	_AccuVelocityY[worldIdx] = 0;
	_AccuVelocityZ[worldIdx] = 0;
}

//---------------------
// kernels: accumulate

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplat(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	//TODO remap and pack according to max velocity within volume
	//float3 velocityStepLimit = _VolumeWorldMax - _VolumeWorldMin;
	//float3 velocityStep = clamp(_ParticleVelocity[worldIdx.x].xyz * _DT, -velocityStepLimit, velocityStepLimit);

	InterlockedAddParticleContribution(worldIdx.x, 1.0, _AccuDensity);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _AccuVelocityX);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _AccuVelocityY);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _AccuVelocityZ);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, 1.0, _AccuDensity);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityX(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _AccuVelocityX);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityY(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _AccuVelocityY);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityZ(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _AccuVelocityZ);
}

//------------------
// kernels: resolve

void VolumeResolveAux(uint3 worldIdx, inout float outDensity, inout float4 outVelocity)
{
	const int accu_n = _AccuDensity[worldIdx];

	const float rho_particle = _StrandParticleVolume / (1e+9 * VolumeWorldCellVolume());
	const float rho_unscaled = accu_n * SPLAT_PRECISION;
#if STRAND_31_32_DEBUG
	const float rho = pow(_StrandParticleContrib, 3.0) * rho_unscaled;
#else
	const float rho = rho_particle * rho_unscaled;
#endif
	
	outDensity += rho;
	
	outVelocity += float4(
		(float3(
			_AccuVelocityX[worldIdx],
			_AccuVelocityY[worldIdx],
			_AccuVelocityZ[worldIdx]) / (float)max(1, accu_n)
		),
		rho_unscaled);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeResolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	float sumDensity = 0.0;
	float4 sumVelocity = float4(0.0, 0.0, 0.0, 0.0);
	
	VolumeResolveAux(worldIdx, sumDensity, sumVelocity);
	
	_VolumeDensity[worldIdx] = sumDensity / 1.0;
	_VolumeVelocity[worldIdx] = sumVelocity / 1.0;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeResolveFromRasterization(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const float4 splat = _VolumeVelocity[worldIdx];
	{
		const float rho_particle = _StrandParticleVolume / (1e+9 * VolumeWorldCellVolume());
		const float rho_unscaled = splat.w;
#if STRAND_31_32_DEBUG
		const float rho = pow(_StrandParticleContrib, 3.0) * rho_unscaled;
#else
		const float rho = rho_particle * rho_unscaled;
#endif

		_VolumeDensity[worldIdx] = rho;

		if (splat.w > 0.0)
			_VolumeVelocity[worldIdx] = float4(splat.xyz / splat.w, splat.w);
		else
			_VolumeVelocity[worldIdx] = 0.0;
	}
}

//---------------------
// kernels: processing

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VolumeWorldCellSize().x);
#else
	const float3 h_inv = 1.0 / (2.0 * VolumeWorldCellSize().xyz);
#endif

	const float3 diff = float3(
		_VolumeDensity[worldIdx + worldIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
		_VolumeDensity[worldIdx + worldIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
		_VolumeDensity[worldIdx + worldIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
		) * h_inv;

	_VolumeDensityGrad[worldIdx] = diff;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeDivergence(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const bool3 isBoundaryLower = (worldIdx == 0);
	const bool3 isBoundaryUpper = (worldIdx == (uint3)_VolumeCells.xyz - 1);

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const float4 v_in = _VolumeVelocity[worldIdx];

#if VOLUME_VOF
	const float min_contrib = 0.0;
	const float max_contrib = 1.0;
	
	const float d_xm = clamp(_VolumeDensity[worldIdx - worldIdxStrideX], min_contrib, max_contrib);
	const float d_ym = clamp(_VolumeDensity[worldIdx - worldIdxStrideY], min_contrib, max_contrib);
	const float d_zm = clamp(_VolumeDensity[worldIdx - worldIdxStrideZ], min_contrib, max_contrib);

	const float d_xp = clamp(_VolumeDensity[worldIdx + worldIdxStrideX], min_contrib, max_contrib);
	const float d_yp = clamp(_VolumeDensity[worldIdx + worldIdxStrideY], min_contrib, max_contrib);
	const float d_zp = clamp(_VolumeDensity[worldIdx + worldIdxStrideZ], min_contrib, max_contrib);
	
	const float w_xm = d_xm;// / max(1e-4, d_xm + d_xp);
	const float w_ym = d_ym;// / max(1e-4, d_ym + d_yp);
	const float w_zm = d_zm;// / max(1e-4, d_zm + d_zp);

	const float w_xp = d_xp;// / max(1e-4, d_xm + d_xp);
	const float w_yp = d_yp;// / max(1e-4, d_ym + d_yp);
	const float w_zp = d_zp;// / max(1e-4, d_zm + d_zp);
	
	const float vx_xm = isBoundaryLower.x ? v_in.x : _VolumeVelocity[worldIdx - worldIdxStrideX].x * w_xm;
	const float vy_ym = isBoundaryLower.y ? v_in.y : _VolumeVelocity[worldIdx - worldIdxStrideY].y * w_ym;
	const float vz_zm = isBoundaryLower.z ? v_in.z : _VolumeVelocity[worldIdx - worldIdxStrideZ].z * w_zm;

	const float vx_xp = isBoundaryUpper.x ? v_in.x : _VolumeVelocity[worldIdx + worldIdxStrideX].x * w_xp;
	const float vy_yp = isBoundaryUpper.y ? v_in.y : _VolumeVelocity[worldIdx + worldIdxStrideY].y * w_yp;
	const float vz_zp = isBoundaryUpper.z ? v_in.z : _VolumeVelocity[worldIdx + worldIdxStrideZ].z * w_zp;
#else
	const float vx_xm = isBoundaryLower.x ? v_in.x : _VolumeVelocity[worldIdx - worldIdxStrideX].x;
	const float vy_ym = isBoundaryLower.y ? v_in.y : _VolumeVelocity[worldIdx - worldIdxStrideY].y;
	const float vz_zm = isBoundaryLower.z ? v_in.z : _VolumeVelocity[worldIdx - worldIdxStrideZ].z;

	const float vx_xp = isBoundaryUpper.x ? v_in.x : _VolumeVelocity[worldIdx + worldIdxStrideX].x;
	const float vy_yp = isBoundaryUpper.y ? v_in.y : _VolumeVelocity[worldIdx + worldIdxStrideY].y;
	const float vz_zp = isBoundaryUpper.z ? v_in.z : _VolumeVelocity[worldIdx + worldIdxStrideZ].z;
#endif

#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VolumeWorldCellSize().x);
	const float div = float(
		(vx_xp - vx_xm) +
		(vy_yp - vy_ym) +
		(vz_zp - vz_zm)) * h_inv;
#else
	const float3 h_inv = 1.0 / (2.0 * VolumeWorldCellSize().xyz);
	const float div = float(
		(vx_xp - vx_xm) * h_inv.x +
		(vy_yp - vy_ym) * h_inv.y +
		(vz_zp - vz_zm) * h_inv.z);
#endif

	const float rho = _VolumeDensity[worldIdx];
	const float rho0 = 1.0;

#if VOLUME_AIR_CELL_ZERO_SOURCE_TERM
	if (rho == 0.0)
	{
		_VolumeDivergence[worldIdx] = div;
	}
	else
#else
	{
		_VolumeDivergence[worldIdx] = div - (rho / rho0 - 1.0)  * (_Repulsion);
	}
#endif
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureEOS(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const float rho = _VolumeDensity[worldIdx];
	const float rho0 = 1.0;

#if VOLUME_AIR_CELL_ZERO_PRESSURE
	if (rho == 0.0)
	{
		_VolumePressure[worldIdx] = 0.0;
		return;
	}
#endif

	_VolumePressure[worldIdx] = (rho / rho0 - 1.0) * (_Repulsion * VolumeWorldCellSize().x * VolumeWorldCellSize().x);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureSolve(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const float rho = _VolumeDensity[worldIdx];
	const float rho0 = 1.0;

#if VOLUME_AIR_CELL_ZERO_PRESSURE
	if (rho == 0.0)
	{
		_VolumePressure[worldIdx] = 0.0;
		return;
	}
#endif
	
	// solve poisson equation for pressure using central differences
	// https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html

	const bool3 isBoundaryLower = (worldIdx == 0);
	const bool3 isBoundaryUpper = (worldIdx == (uint3)_VolumeCells.xyz - 1);
	
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_GHOST
	const uint3 i_xm = worldIdx - worldIdxStrideX;
	const uint3 i_ym = worldIdx - worldIdxStrideY;
	const uint3 i_zm = worldIdx - worldIdxStrideZ;
	
	const uint3 i_xp = worldIdx + worldIdxStrideX;
	const uint3 i_yp = worldIdx + worldIdxStrideY;
	const uint3 i_zp = worldIdx + worldIdxStrideZ;
	
	const float tmp_p_xm = isBoundaryLower.x ? p_in : _VolumePressure[worldIdx - worldIdxStrideX];
	const float tmp_p_ym = isBoundaryLower.y ? p_in : _VolumePressure[worldIdx - worldIdxStrideY];
	const float tmp_p_zm = isBoundaryLower.z ? p_in : _VolumePressure[worldIdx - worldIdxStrideZ];

	const float tmp_p_xp = isBoundaryUpper.x ? p_in : _VolumePressure[worldIdx + worldIdxStrideX];
	const float tmp_p_yp = isBoundaryUpper.y ? p_in : _VolumePressure[worldIdx + worldIdxStrideY];
	const float tmp_p_zp = isBoundaryUpper.z ? p_in : _VolumePressure[worldIdx + worldIdxStrideZ];

	const float p_in = _VolumePressurePrev[worldIdx];
	
	const float p_xm = GhostPressure(i_xm, p_in, tmp_p_xp);
	const float p_ym = GhostPressure(i_ym, p_in, tmp_p_yp);
	const float p_zm = GhostPressure(i_zm, p_in, tmp_p_zp);

	const float p_xp = GhostPressure(i_xp, p_in, tmp_p_xm);
	const float p_yp = GhostPressure(i_yp, p_in, tmp_p_ym);
	const float p_zp = GhostPressure(i_zp, p_in, tmp_p_zm);	
#else
	const float p_in = _VolumePressurePrev[worldIdx];
	
	const float p_xm = isBoundaryLower.x ? p_in : _VolumePressurePrev[worldIdx - worldIdxStrideX];
	const float p_ym = isBoundaryLower.y ? p_in : _VolumePressurePrev[worldIdx - worldIdxStrideY];
	const float p_zm = isBoundaryLower.z ? p_in : _VolumePressurePrev[worldIdx - worldIdxStrideZ];

	const float p_xp = isBoundaryUpper.x ? p_in : _VolumePressurePrev[worldIdx + worldIdxStrideX];
	const float p_yp = isBoundaryUpper.y ? p_in : _VolumePressurePrev[worldIdx + worldIdxStrideY];
	const float p_zp = isBoundaryUpper.z ? p_in : _VolumePressurePrev[worldIdx + worldIdxStrideZ];
#endif

	const float b = _VolumeDivergence[worldIdx];
	const float w = 1.0;// SOR factor [1..2]

#if VOLUME_SQUARE_CELLS
	const float h = VolumeWorldCellSize().x;
	const float a = -(h * h);

	const float pressure =
		(1.0 - w) * p_in +
		(w / 6.0) * float(
			p_xm + p_xp +
			p_ym + p_yp +
			p_zm + p_zp +
			a * b);
#else
	const float3 h = VolumeWorldCellSize().xyz;
	const float3 a = -(h * h) / 3.0;

	const float pressure =
		(1.0 - w) * p_in +
		(w / 6.0) * float(
			(p_xm + p_xp + a.x * b) + 
			(p_ym + p_yp + a.y * b) +
			(p_zm + p_zp + a.z * b));
#endif

	_VolumePressure[worldIdx] = pressure;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
#if VOLUME_AIR_CELL_ZERO_PRESSURE_GRAD
	const float rho = _VolumeDensity[worldIdx];
	const float rho0 = 1.0;
	
	if (rho == 0.0)
	{
		_VolumePressureGrad[worldIdx] = 0.0;
		return;
	}
#endif

	const bool3 isBoundaryLower = (worldIdx == 0);
	const bool3 isBoundaryUpper = (worldIdx == (uint3)_VolumeCells.xyz - 1);

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const float p_in = _VolumePressure[worldIdx];

#if VOLUME_GHOST
	const uint3 i_xm = worldIdx - worldIdxStrideX;
	const uint3 i_ym = worldIdx - worldIdxStrideY;
	const uint3 i_zm = worldIdx - worldIdxStrideZ;
	
	const uint3 i_xp = worldIdx + worldIdxStrideX;
	const uint3 i_yp = worldIdx + worldIdxStrideY;
	const uint3 i_zp = worldIdx + worldIdxStrideZ;
	
	const float tmp_p_xm = isBoundaryLower.x ? p_in : _VolumePressure[worldIdx - worldIdxStrideX];
	const float tmp_p_ym = isBoundaryLower.y ? p_in : _VolumePressure[worldIdx - worldIdxStrideY];
	const float tmp_p_zm = isBoundaryLower.z ? p_in : _VolumePressure[worldIdx - worldIdxStrideZ];

	const float tmp_p_xp = isBoundaryUpper.x ? p_in : _VolumePressure[worldIdx + worldIdxStrideX];
	const float tmp_p_yp = isBoundaryUpper.y ? p_in : _VolumePressure[worldIdx + worldIdxStrideY];
	const float tmp_p_zp = isBoundaryUpper.z ? p_in : _VolumePressure[worldIdx + worldIdxStrideZ];
	
	const float p_xm = GhostPressure(i_xm, p_in, tmp_p_xp);
	const float p_ym = GhostPressure(i_ym, p_in, tmp_p_yp);
	const float p_zm = GhostPressure(i_zm, p_in, tmp_p_zp);

	const float p_xp = GhostPressure(i_xp, p_in, tmp_p_xm);
	const float p_yp = GhostPressure(i_yp, p_in, tmp_p_ym);
	const float p_zp = GhostPressure(i_zp, p_in, tmp_p_zm);
#else
	const float p_xm = isBoundaryLower.x ? p_in : _VolumePressure[worldIdx - worldIdxStrideX];
	const float p_ym = isBoundaryLower.y ? p_in : _VolumePressure[worldIdx - worldIdxStrideY];
	const float p_zm = isBoundaryLower.z ? p_in : _VolumePressure[worldIdx - worldIdxStrideZ];

	const float p_xp = isBoundaryUpper.x ? p_in : _VolumePressure[worldIdx + worldIdxStrideX];
	const float p_yp = isBoundaryUpper.y ? p_in : _VolumePressure[worldIdx + worldIdxStrideY];
	const float p_zp = isBoundaryUpper.z ? p_in : _VolumePressure[worldIdx + worldIdxStrideZ];
#endif
	
#if VOLUME_SQUARE_CELLS
	const float h_inv = 1.0 / (2.0 * VolumeWorldCellSize().x);
#else
	const float3 h_inv = 1.0 / (2.0 * VolumeWorldCellSize().xyz);
#endif

	const float3 diff = float3(
		p_xp - p_xm,
		p_yp - p_ym,
		p_zp - p_zm) * h_inv;

	_VolumePressureGrad[worldIdx] = diff;
}
