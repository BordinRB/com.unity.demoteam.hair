#pragma kernel KVolumeClear
#pragma kernel KVolumeDensity
#pragma kernel KVolumeGradient

StructuredBuffer<float4> _ParticlePosition;

float3 _VolumeCells;
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;
/*
    _VolumeCells = (3, 3, 3)

              +---+---+---+
         +---+---+---+  q |
    +---+---+---+    | ---+
    |   |   |   | ---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+    |
    +---+---+---+    | ---+
    | p |   |   | ---+
    +---+---+---+

    _VolumeWorldMin = p
    _VolumeWorldMax = q
*/

RWTexture3D<int> _VolumeDensity;
RWTexture3D<float3> _VolumeGradient;

uint3 ParticleVolumeIndex(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 worldPosClamped = clamp(worldPos, _VolumeWorldMin, _VolumeWorldMax);

	float3 localPos = (worldPosClamped - _VolumeWorldMin) * (_VolumeCells / (_VolumeWorldMax - _VolumeWorldMin));
	float3 localPosQuantized = round(localPos);

	return localPosQuantized;
}

float3 ParticleVolumePosition(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 worldPosClamped = clamp(worldPos, _VolumeWorldMin, _VolumeWorldMax);

	float3 localPos = (worldPosClamped - _VolumeWorldMin) * (_VolumeCells / (_VolumeWorldMax - _VolumeWorldMin));
	return localPos;
}

#define CLEAR_WIDTH 8
#define CLEAR_NUM_X CLEAR_WIDTH
#define CLEAR_NUM_Y CLEAR_WIDTH
#define CLEAR_NUM_Z CLEAR_WIDTH

[numthreads(CLEAR_NUM_X, CLEAR_NUM_Y, CLEAR_NUM_Z)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeDensity[worldIdx] = 0;
}

#define SIMPLE 1
#define SCALE 255.0

[numthreads(64, 1, 1)]
void KVolumeDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
#if SIMPLE

	InterlockedAdd(_VolumeDensity[ParticleVolumeIndex(worldIdx.x)], 1);

#else

	float3 volumePos = ParticleVolumePosition(worldIdx.x);
	float3 volumePosFloor = floor(volumePos);

	const float k = SCALE;
	const uint2 h = uint2(1, 0);

	uint3 index0 = volumePosFloor;
	uint3 w0 = k * (volumePos - volumePosFloor);
	uint3 w1 = k - w0;

	InterlockedAdd(_VolumeDensity[index0 + h.yyy], (int)(h.yyy ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.xyy], (int)(h.xyy ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.yxy], (int)(h.yxy ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.xxy], (int)(h.xxy ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.yyx], (int)(h.yyx ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.xyx], (int)(h.xyx ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.yxx], (int)(h.yxx ? w1 : w0));
	InterlockedAdd(_VolumeDensity[index0 + h.xxx], (int)(h.xxx ? w1 : w0));

#endif
}

#define GRADIENT_WIDTH 4
#define GRADIENT_NUM_X GRADIENT_WIDTH
#define GRADIENT_NUM_Y GRADIENT_WIDTH
#define GRADIENT_NUM_Z GRADIENT_WIDTH

groupshared int gs_density[GRADIENT_NUM_X * GRADIENT_NUM_Y * GRADIENT_NUM_Z];

[numthreads(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z)]
void KVolumeGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint threadIdxStrideX = 1;
	const uint threadIdxStrideY = GRADIENT_NUM_X;
	const uint threadIdxStrideZ = GRADIENT_NUM_X * GRADIENT_NUM_Y;
	/*
	SV_GroupIndex =
		SV_GroupThreadID.z*dimx*dimy +
		SV_GroupThreadID.y*dimx +
		SV_GroupThreadID.x
	*/

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z) - 1;

#if SIMPLE
	const float scale = 1.0;
#else
	const float scale = SCALE;
#endif

	if (any(localIdx == localLowerIdx))
	{
		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
			) / (2.0f * scale);

		_VolumeGradient[worldIdx] = -(diff);
	}
	else if (any(localIdx == localUpperIdx))
	{
		float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) / (2.0f * scale);

		_VolumeGradient[worldIdx] = -(diff);
	}
	else
	{
		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) / (2.0f * scale);

		_VolumeGradient[worldIdx] = -(diff);
	}
}

[numthreads(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z)]
void KVolumeGradientFDiff(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(GRADIENT_NUM_X, GRADIENT_NUM_Y, GRADIENT_NUM_Z) - 1;

	if (any(localIdx == localUpperIdx))
	{
		const uint3 worldIdxStrideX = uint3(1, 0, 0);
		const uint3 worldIdxStrideY = uint3(0, 1, 0);
		const uint3 worldIdxStrideZ = uint3(0, 0, 1);

		float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx]
			);

		_VolumeGradient[worldIdx] = -(diff);
	}
	else
	{
		const uint threadIdxStrideX = 1;
		const uint threadIdxStrideY = GRADIENT_NUM_X;
		const uint threadIdxStrideZ = GRADIENT_NUM_X * GRADIENT_NUM_Y;
		/*
		SV_GroupIndex =
			SV_GroupThreadID.z*dimx*dimy +
			SV_GroupThreadID.y*dimx +
			SV_GroupThreadID.x
		*/

		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx]
			);

		_VolumeGradient[worldIdx] = -(diff);
	}
}
