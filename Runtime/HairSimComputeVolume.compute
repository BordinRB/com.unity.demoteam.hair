#pragma kernel KVolumeClear
#pragma kernel KVolumeSplatDensityVelocity
#pragma kernel KVolumeSplatDensity
#pragma kernel KVolumeSplatVelocityX
#pragma kernel KVolumeSplatVelocityY
#pragma kernel KVolumeSplatVelocityZ
#pragma kernel KVolumeResolveVelocity
#pragma kernel KVolumeResolveVelocityDensity
#pragma kernel KVolumeGradient
#pragma kernel KVolumeDivergence
#pragma kernel KVolumePressureIteration
#pragma kernel KVolumePressureGradient
#pragma kernel KVolumeVelocitySolenoidal

#define HAIRSIM_WRITEABLE_VOLUMEDATA 1

#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverData.hlsl"
#include "HairSimComputeVolumeData.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

#define PARTICLE_NUM_X 64
#define PARTICLE_NUM_Y 1
#define PARTICLE_NUM_Z 1

#define VOLUME_NUM_X 4
#define VOLUME_NUM_Y 4
#define VOLUME_NUM_Z 4

//---------
// utility

void InterlockedAddTrilinear(RWTexture3D<int> volume, uint3 idx0, float value, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedAdd(volume[idx0 + h.yyy], (int)(value * w0.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xyy], (int)(value * w1.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yxy], (int)(value * w0.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xxy], (int)(value * w1.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yyx], (int)(value * w0.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xyx], (int)(value * w1.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.yxx], (int)(value * w0.x * w1.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xxx], (int)(value * w1.x * w1.y * w1.z));
}

void InterlockedAddParticleContribution(uint i, float value, RWTexture3D<int> volume)
{
#if DENSITY_TRILINEAR
	float3 localPos = VolumeWorldToLocal(_ParticlePosition[i].xyz) - 0.5;// subtract offset to cell center
	float3 localPosFloor = floor(localPos);

	uint3 cellIdx0 = localPosFloor;
	float3 cellPos = localPos - localPosFloor;

	float3 w0 = 1.0 - cellPos;
	float3 w1 = cellPos;

	InterlockedAddTrilinear(volume, cellIdx0, DENSITY_SCALE * value, w0, w1);
#else
	InterlockedAdd(volume[VolumeWorldToIndex(_ParticlePosition[i].xyz)], (int)(DENSITY_SCALE * value));
#endif
}

//---------
// kernels

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeDensity[worldIdx] = 0;
	_VolumeVelocityX[worldIdx] = 0;
	_VolumeVelocityY[worldIdx] = 0;
	_VolumeVelocityZ[worldIdx] = 0;
	_VolumePressure[worldIdx] = 0;
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatDensityVelocity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	//TODO remapping
	//float3 velocityStepLimit = _VolumeWorldMax - _VolumeWorldMin;
	//float3 velocityStep = clamp(_ParticleVelocity[worldIdx.x].xyz * _DT, -velocityStepLimit, velocityStepLimit);

	InterlockedAddParticleContribution(worldIdx.x, 1.0, _VolumeDensity);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _VolumeVelocityX);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _VolumeVelocityY);
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _VolumeVelocityZ);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, 1.0, _VolumeDensity);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityX(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _VolumeVelocityX);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityY(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _VolumeVelocityY);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeSplatVelocityZ(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _VolumeVelocityZ);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeResolveVelocity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeVelocity[worldIdx] = float4(
		float3(
			_VolumeVelocityX[worldIdx],
			_VolumeVelocityY[worldIdx],
			_VolumeVelocityZ[worldIdx]) / (float)max(1, _VolumeDensity[worldIdx])
		,
		_VolumeDensity[worldIdx] / DENSITY_SCALE
		);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeResolveVelocityDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	float4 splat = _VolumeVelocity[worldIdx];
	{
		_VolumeDensity[worldIdx] = splat.w * DENSITY_SCALE;
		_VolumeVelocity[worldIdx] = float4(splat.xyz / max(1e-4, splat.w), splat.w);
	}
}

groupshared int gs_density[VOLUME_NUM_X * VOLUME_NUM_Y * VOLUME_NUM_Z];

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
#if 1
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_SQUARE_CELLS
	const float k = 1.0 / (2.0 * DENSITY_SCALE);// *VolumeWorldCellSize().x);
#else
	const float3 k = 1.0 / (2.0 * DENSITY_SCALE);// *VolumeWorldCellSize());
#endif

	float3 diff = float3(
		_VolumeDensity[worldIdx + worldIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
		_VolumeDensity[worldIdx + worldIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
		_VolumeDensity[worldIdx + worldIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
		) * k;

	_VolumeGradient[worldIdx] = diff;
#else
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint threadIdxStrideX = 1;
	const uint threadIdxStrideY = VOLUME_NUM_X;
	const uint threadIdxStrideZ = VOLUME_NUM_X * VOLUME_NUM_Y;
	/*
	SV_GroupIndex =
		SV_GroupThreadID.z*dimx*dimy +
		SV_GroupThreadID.y*dimx +
		SV_GroupThreadID.x
	*/

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z) - 1;

#if VOLUME_SQUARE_CELLS
	const float k = 1.0 / (2.0 * DENSITY_SCALE);// *VolumeWorldCellSize().x);
#else
	const float3 k = 1.0 / (2.0 * DENSITY_SCALE);// *VolumeWorldCellSize());
#endif

	const bool lowerBoundary = any(localIdx == localLowerIdx);
	const bool upperBoundary = any(localIdx == localUpperIdx);

	if (lowerBoundary || upperBoundary)
	{
		if (lowerBoundary && upperBoundary)
		{
			float3 diff = float3(
				_VolumeDensity[worldIdx + worldIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
				_VolumeDensity[worldIdx + worldIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
				_VolumeDensity[worldIdx + worldIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
				) * k;

			_VolumeGradient[worldIdx] = diff;
		}
		else if (lowerBoundary)
		{
			float3 diff = float3(
				gs_density[threadIdx + threadIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
				gs_density[threadIdx + threadIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
				gs_density[threadIdx + threadIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
				) * k;

			_VolumeGradient[worldIdx] = diff;
		}
		else// upperBoundary
		{
			float3 diff = float3(
				_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
				_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
				_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
				) * k;

			_VolumeGradient[worldIdx] = diff;
		}
	}
	else
	{
		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) * k;

		_VolumeGradient[worldIdx] = diff;
	}
#endif
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradientForwardDiff(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z) - 1;

	const float k = 1.0 / DENSITY_SCALE;

	if (any(localIdx == localUpperIdx))
	{
		const uint3 worldIdxStrideX = uint3(1, 0, 0);
		const uint3 worldIdxStrideY = uint3(0, 1, 0);
		const uint3 worldIdxStrideZ = uint3(0, 0, 1);

		float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx]
			) * k;

		_VolumeGradient[worldIdx] = diff;
	}
	else
	{
		const uint threadIdxStrideX = 1;
		const uint threadIdxStrideY = VOLUME_NUM_X;
		const uint threadIdxStrideZ = VOLUME_NUM_X * VOLUME_NUM_Y;
		/*
		SV_GroupIndex =
			SV_GroupThreadID.z*dimx*dimy +
			SV_GroupThreadID.y*dimx +
			SV_GroupThreadID.x
		*/

		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx]
			) * k;

		_VolumeGradient[worldIdx] = diff;
	}
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeDivergence(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	float vx_x0 = _VolumeVelocity[worldIdx - worldIdxStrideX].x;
	float vy_y0 = _VolumeVelocity[worldIdx - worldIdxStrideY].y;
	float vz_z0 = _VolumeVelocity[worldIdx - worldIdxStrideZ].z;

	float vx_x2 = _VolumeVelocity[worldIdx + worldIdxStrideX].x;
	float vy_y2 = _VolumeVelocity[worldIdx + worldIdxStrideY].y;
	float vz_z2 = _VolumeVelocity[worldIdx + worldIdxStrideZ].z;

#if VOLUME_SQUARE_CELLS
	float k = 1.0 / (2.0 * VolumeWorldCellSize().x);
	float div = float(
		vx_x2 + vy_y2 + vz_z2 -
		vx_x0 - vy_y0 - vz_z0
		) * k;
#else
	float3 k = 1.0 / (2.0 * VolumeWorldCellSize());
	float div = float(
		(vx_x2 - vx_x0) * k.x +
		(vy_y2 - vy_y0) * k.y +
		(vz_z2 - vz_z0) * k.z);
#endif

	_VolumeDivergence[worldIdx] = div;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureIteration(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	// solve poisson equation for pressure using central differences
	// https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html

	if (_VolumeDensity[worldIdx] == 0)
	{
		return;// p remains 0 (Dirichlet boundary condation)
	}

	float p_x0 = _VolumePressure0[worldIdx - worldIdxStrideX];
	float p_y0 = _VolumePressure0[worldIdx - worldIdxStrideY];
	float p_z0 = _VolumePressure0[worldIdx - worldIdxStrideZ];

	float p_x2 = _VolumePressure0[worldIdx + worldIdxStrideX];
	float p_y2 = _VolumePressure0[worldIdx + worldIdxStrideY];
	float p_z2 = _VolumePressure0[worldIdx + worldIdxStrideZ];

	float b = _VolumeDivergence[worldIdx];

#if VOLUME_SQUARE_CELLS
	float d = VolumeWorldCellSize().x;
	float a = -(d * d);
	float p = float(
		p_x0 + p_x2 +
		p_y0 + p_y2 +
		p_z0 + p_z2 +
		a * b) / 6.0;
#else
	float3 d = VolumeWorldCellSize();
	float3 a = -(d * d) / 3.0;
	float p = float(
		(p_x0 + p_x2 + a.x * b) + 
		(p_y0 + p_y2 + a.y * b) +
		(p_z0 + p_z2 + a.z * b)) / 6.0;
#endif

	_VolumePressure[worldIdx] = p;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumePressureGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

#if VOLUME_SQUARE_CELLS
	const float k = 1.0 / (2.0 * VolumeWorldCellSize().x);
#else
	const float3 k = 1.0 / (2.0 * VolumeWorldCellSize());
#endif

	float3 diff = float3(
		_VolumePressure[worldIdx + worldIdxStrideX] - _VolumePressure[worldIdx - worldIdxStrideX],
		_VolumePressure[worldIdx + worldIdxStrideY] - _VolumePressure[worldIdx - worldIdxStrideY],
		_VolumePressure[worldIdx + worldIdxStrideZ] - _VolumePressure[worldIdx - worldIdxStrideZ]
		) * k;

	_VolumePressureGradient[worldIdx] = diff;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeVelocitySolenoidal(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeVelocitySolenoidal[worldIdx] = _VolumeVelocity[worldIdx].xyz - _VolumePressureGradient[worldIdx];
}
