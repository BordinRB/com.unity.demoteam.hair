#pragma kernel KVolumeClear
#pragma kernel KVolumeDensity
#pragma kernel KVolumeVelocityX
#pragma kernel KVolumeVelocityY
#pragma kernel KVolumeVelocityZ
#pragma kernel KVolumeVelocity
#pragma kernel KVolumeVelocityDensity
#pragma kernel KVolumeGradient

//#include "HairSimComputeConfig.hlsl"
#define DENSITY_SCALE 8192.0
#define DENSITY_TRILINEAR 1

#define PARTICLE_NUM_X 64
#define PARTICLE_NUM_Y 1
#define PARTICLE_NUM_Z 1

#define VOLUME_NUM_X 4
#define VOLUME_NUM_Y 4
#define VOLUME_NUM_Z 4

StructuredBuffer<float4> _ParticlePosition;
StructuredBuffer<float4> _ParticleVelocity;

float3 _VolumeCells;
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;
/*
    _VolumeCells = (4, 4, 4)

              +---+---+---Q
         +---+---+---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+    |
    +---+---+---+    | ---+
    |   |   |   | ---+
    P---+---+---+

    _VolumeWorldMin = P
    _VolumeWorldMax = Q
*/

RWTexture3D<int> _VolumeDensity;
RWTexture3D<int> _VolumeVelocityX;// this sure would be nice: https://developer.nvidia.com/unlocking-gpu-intrinsics-hlsl
RWTexture3D<int> _VolumeVelocityY;
RWTexture3D<int> _VolumeVelocityZ;
RWTexture3D<float4> _VolumeVelocity;
RWTexture3D<float3> _VolumeGradient;

float3 ParticleVolumePosition(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 localUVW = (worldPos - _VolumeWorldMin) / (_VolumeWorldMax - _VolumeWorldMin);
	float3 localPos = (_VolumeCells - 1) * saturate(localUVW);
	return localPos;
}

uint3 ParticleVolumeIndex(uint i)
{
	float3 localPos = ParticleVolumePosition(i);
	float3 localPosQuantized = round(localPos);
	return localPosQuantized;
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeClear(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeDensity[worldIdx] = 0;
	_VolumeVelocityX[worldIdx] = 0;
	_VolumeVelocityY[worldIdx] = 0;
	_VolumeVelocityZ[worldIdx] = 0;
}

void InterlockedAddTrilinear(RWTexture3D<int> volume, uint3 idx0, float value, float3 w0, float3 w1)
{
	const uint2 h = uint2(1, 0);
	InterlockedAdd(volume[idx0 + h.yyy], (int)(value * w0.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xyy], (int)(value * w1.x * w0.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yxy], (int)(value * w0.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.xxy], (int)(value * w1.x * w1.y * w0.z));
	InterlockedAdd(volume[idx0 + h.yyx], (int)(value * w0.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xyx], (int)(value * w1.x * w0.y * w1.z));
	InterlockedAdd(volume[idx0 + h.yxx], (int)(value * w0.x * w1.y * w1.z));
	InterlockedAdd(volume[idx0 + h.xxx], (int)(value * w1.x * w1.y * w1.z));
}

void InterlockedAddParticleContribution(uint i, float value, RWTexture3D<int> volume)
{
#if DENSITY_TRILINEAR
	float3 volumePos = ParticleVolumePosition(i);
	float3 volumePosFloor = floor(volumePos);

	uint3 cellIdx0 = volumePosFloor;
	float3 cellPos = volumePos - volumePosFloor;

	float3 w0 = 1.0 - cellPos;
	float3 w1 = cellPos;

	InterlockedAddTrilinear(volume, cellIdx0, DENSITY_SCALE * value, w0, w1);
#else
	InterlockedAdd(volume[ParticleVolumeIndex(i)], DENSITY_SCALE);
#endif
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, 1.0, _VolumeDensity);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeVelocityX(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].x, _VolumeVelocityX);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeVelocityY(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].y, _VolumeVelocityY);
}

[numthreads(PARTICLE_NUM_X, PARTICLE_NUM_Y, PARTICLE_NUM_Z)]
void KVolumeVelocityZ(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	InterlockedAddParticleContribution(worldIdx.x, _ParticleVelocity[worldIdx.x].z, _VolumeVelocityZ);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeVelocity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	_VolumeVelocity[worldIdx] = float4(
		_VolumeVelocityX[worldIdx],
		_VolumeVelocityY[worldIdx],
		_VolumeVelocityZ[worldIdx], 0) / (float)max(1, _VolumeDensity[worldIdx]);
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeVelocityDensity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	float4 volumeSplat = _VolumeVelocity[worldIdx];
	_VolumeDensity[worldIdx] = volumeSplat.w * DENSITY_SCALE;
	_VolumeVelocity[worldIdx] = volumeSplat / max(1e-4, volumeSplat.w);
}

groupshared int gs_density[VOLUME_NUM_X * VOLUME_NUM_Y * VOLUME_NUM_Z];

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradient(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint threadIdxStrideX = 1;
	const uint threadIdxStrideY = VOLUME_NUM_X;
	const uint threadIdxStrideZ = VOLUME_NUM_X * VOLUME_NUM_Y;
	/*
	SV_GroupIndex =
		SV_GroupThreadID.z*dimx*dimy +
		SV_GroupThreadID.y*dimx +
		SV_GroupThreadID.x
	*/

	const uint3 worldIdxStrideX = uint3(1, 0, 0);
	const uint3 worldIdxStrideY = uint3(0, 1, 0);
	const uint3 worldIdxStrideZ = uint3(0, 0, 1);

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z) - 1;

	const bool lowerBoundary = any(localIdx == localLowerIdx);
	const bool upperBoundary = any(localIdx == localUpperIdx);

	const float k = 1.0 / (2.0 * DENSITY_SCALE);

	if (lowerBoundary || upperBoundary)
	{
		if (lowerBoundary && upperBoundary)
		{
			float3 diff = float3(
				_VolumeDensity[worldIdx + worldIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
				_VolumeDensity[worldIdx + worldIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
				_VolumeDensity[worldIdx + worldIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
				) * k;

			_VolumeGradient[worldIdx] = -diff;
		}
		else if (lowerBoundary)
		{
			float3 diff = float3(
				gs_density[threadIdx + threadIdxStrideX] - _VolumeDensity[worldIdx - worldIdxStrideX],
				gs_density[threadIdx + threadIdxStrideY] - _VolumeDensity[worldIdx - worldIdxStrideY],
				gs_density[threadIdx + threadIdxStrideZ] - _VolumeDensity[worldIdx - worldIdxStrideZ]
				) * k;

			_VolumeGradient[worldIdx] = -diff;
		}
		else// upperBoundary
		{
			float3 diff = float3(
				_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
				_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
				_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
				) * k;

			_VolumeGradient[worldIdx] = -diff;
		}
	}
	else
	{
		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx - threadIdxStrideX],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx - threadIdxStrideY],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx - threadIdxStrideZ]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
}

[numthreads(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z)]
void KVolumeGradientForwardDiff(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	gs_density[threadIdx] = _VolumeDensity[worldIdx];

	GroupMemoryBarrierWithGroupSync();

	const uint3 localLowerIdx = 0;
	const uint3 localUpperIdx = uint3(VOLUME_NUM_X, VOLUME_NUM_Y, VOLUME_NUM_Z) - 1;

	const float k = 1.0 / DENSITY_SCALE;

	if (any(localIdx == localUpperIdx))
	{
		const uint3 worldIdxStrideX = uint3(1, 0, 0);
		const uint3 worldIdxStrideY = uint3(0, 1, 0);
		const uint3 worldIdxStrideZ = uint3(0, 0, 1);

		float3 diff = float3(
			_VolumeDensity[worldIdx + worldIdxStrideX] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideY] - gs_density[threadIdx],
			_VolumeDensity[worldIdx + worldIdxStrideZ] - gs_density[threadIdx]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
	else
	{
		const uint threadIdxStrideX = 1;
		const uint threadIdxStrideY = VOLUME_NUM_X;
		const uint threadIdxStrideZ = VOLUME_NUM_X * VOLUME_NUM_Y;
		/*
		SV_GroupIndex =
			SV_GroupThreadID.z*dimx*dimy +
			SV_GroupThreadID.y*dimx +
			SV_GroupThreadID.x
		*/

		float3 diff = float3(
			gs_density[threadIdx + threadIdxStrideX] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideY] - gs_density[threadIdx],
			gs_density[threadIdx + threadIdxStrideZ] - gs_density[threadIdx]
			) * k;

		_VolumeGradient[worldIdx] = -diff;
	}
}
