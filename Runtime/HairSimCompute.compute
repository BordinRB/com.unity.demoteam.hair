#pragma kernel KUpdatePosition							THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128
#pragma kernel KUpdateVelocity							THREAD_GROUP_SIZE=64

//#include "HairSimComputeConfig.hlsl"
#define LAYOUT_INTERLEAVED 1
#define MAX_BOUNDARIES 8
#define DENSITY_SCALE 8192.0

float4x4 _LocalToWorld;
float4x4 _LocalToWorldInvT;

uint _StrandCount;
uint _StrandParticleCount;
float _StrandParticleInterval;

float _DT;
uint _Iterations;
float _Inference;
float _Stiffness;
float _Damping;
float _Gravity;
float _Repulsion;
float _Friction;

float _BendingCurvature;
float _BendingRestRadius;
float _DampingFTL;

StructuredBuffer<float4> _RootPosition;
StructuredBuffer<float4> _RootTangent;

StructuredBuffer<float4> _ParticlePositionPrev;
StructuredBuffer<float4> _ParticleVelocityPrev;

RWStructuredBuffer<float4> _ParticlePosition;
RWStructuredBuffer<float4> _ParticlePositionCorr;
RWStructuredBuffer<float4> _ParticleVelocity;

//--------
// volume

float3 _VolumeCells;
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;

Texture3D<int> _VolumeDensity;
Texture3D<int> _VolumeVelocityX;
Texture3D<int> _VolumeVelocityY;
Texture3D<int> _VolumeVelocityZ;
Texture3D<float3> _VolumeVelocity;
Texture3D<float3> _VolumeGradient;
SamplerState sampler_VolumeVelocity;
SamplerState sampler_VolumeGradient;

float3 NormalizeElseZero(float3 n)
{
	float d = dot(n, n);
	if (d > 0.0)
		return n * rsqrt(d);
	else
		return 0;
}

float3 ParticleVolumePosition(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 localUVW = (worldPos - _VolumeWorldMin) / (_VolumeWorldMax - _VolumeWorldMin);
	float3 localPos = (_VolumeCells - 1) * saturate(localUVW);
	return localPos;

	//float3 worldPos = _ParticlePosition[i].xyz;
	//float3 worldPosClamped = clamp(worldPos, _VolumeWorldMin, _VolumeWorldMax);
	//float3 localPos = (worldPosClamped - _VolumeWorldMin) * ((_VolumeCells - 1) / (_VolumeWorldMax - _VolumeWorldMin));
	//return localPos;
}

uint3 ParticleVolumeIndex(uint i)
{
	float3 localPos = ParticleVolumePosition(i);
	float3 localPosQuantized = round(localPos);
	return localPosQuantized;
}

float3 ParticleVolumeForce(uint i)
{
#if 1
	float3 volumeUVW = ParticleVolumePosition(i) / (_VolumeCells - 1);
	float3 volumeGradient = _VolumeGradient.SampleLevel(sampler_VolumeGradient, volumeUVW, 0);
	return volumeGradient * _Repulsion;
#else
	uint3 volumeIdx = ParticleVolumeIndex(i);
	float3 volumeGradient = _VolumeGradient[volumeIdx];
	return volumeGradient * _Repulsion;
#endif
}

float3 ParticleVolumeFrictionImpulse(uint i, float3 velocity, float friction)
{
#if 1
	float3 volumeUVW = ParticleVolumePosition(i) / (_VolumeCells - 1);
	float3 volumeVelocity = _VolumeVelocity.SampleLevel(sampler_VolumeVelocity, volumeUVW, 0);
	return (volumeVelocity - velocity) * friction;
#else
	uint3 volumeIdx = ParticleVolumeIndex(i);
	float3 volumeVelocity = _VolumeVelocity[volumeIdx];
	return (volumeVelocity - velocity) * friction;
#endif
}

//------------
// boundaries

struct BoundaryCapsule { float3 centerA; float radius; float3 centerB; float __pad__; };
struct BoundarySphere { float3 center; float radius; };
struct BoundaryTorus { float3 center; float radiusA; float3 axis; float radiusB; };
struct BoundaryPack
{
	//	shape	|	capsule		sphere		torus
	//	----------------------------------------------
	//	float3	|	centerA		center		center
	//	float	|	radius		radius		radiusA
	//	float3	|	centerB		__pad__		axis
	//	float	|	__pad__		__pad__		radiusB

	float3 pA;
	float tA;
	float3 pB;
	float tB;
};

StructuredBuffer<BoundaryCapsule> _BoundaryCapsule;
StructuredBuffer<BoundarySphere> _BoundarySphere;
StructuredBuffer<BoundaryTorus> _BoundaryTorus; 
StructuredBuffer<BoundaryPack> _BoundaryPack;

uint _BoundaryCapsuleCount;
uint _BoundarySphereCount;
uint _BoundaryTorusCount;

float BoundaryDistance(in float3 p)
{
	float d = 1e+7;

#if 1
	// capsules
	{
		for (uint i = 0; i != _BoundaryCapsuleCount; i++)
		{
			BoundaryCapsule capsule = _BoundaryCapsule[i];

			float3 pa = p - capsule.centerA;
			float3 ba = capsule.centerB - capsule.centerA;

			float h = clamp(dot(pa, ba) / dot(ba, ba), 0, 1);
			float r = capsule.radius;

			d = min(d, length(pa - ba * h) - r);
		}
	}

	// spheres
	{
		for (uint i = 0; i != _BoundarySphereCount; i++)
		{
			BoundarySphere sphere = _BoundarySphere[i];

			float3 a = sphere.center;
			float r = sphere.radius;

			d = min(d, length(a - p) - r);
		}
	}

	// tori
	{
		for (uint i = 0; i != _BoundaryTorusCount; i++)
		{
			BoundaryTorus torus = _BoundaryTorus[i];
			//TODO
		}
	}
#else
	uint i = 0;
	uint j = 0;

	// capsules
	{
		for (j += _BoundaryCapsuleCount; i < j; i++)
		{
			BoundaryPack capsulePack = _BoundaryPack[i];

			float3 pa = p - capsulePack.pA;
			float3 ba = capsulePack.pB - capsulePack.pA;

			float h = clamp(dot(pa, ba) / dot(ba, ba), 0, 1);
			float r = capsulePack.tA;

			d = min(d, length(pa - ba * h) - r);
		}
	}

	// spheres
	{
		for (j += _BoundarySphereCount; i < j; i++)
		{
			BoundaryPack spherePack = _BoundaryPack[i];

			float3 a = spherePack.pA;
			float r = spherePack.tA;

			d = min(d, length(a - p) - r);
		}
	}

	// tori
	{
		for (j += _BoundaryTorusCount; i < j; i++)
		{
			BoundaryPack torusPack = _BoundaryPack[i];
			//TODO
		}
	}
#endif

	return d;
}

float3 BoundaryNormal(in float3 p, in float d)
{
	const float2 h = float2(1e-4, 0.0);
	return normalize(float3(
		BoundaryDistance(p - h.xyy) - d,
		BoundaryDistance(p - h.yxy) - d,
		BoundaryDistance(p - h.yyx) - d
	));
}

float3 BoundaryNormal(in float3 p)
{
	return BoundaryNormal(p, BoundaryDistance(p));
}

float4 BoundaryNormalDistance(in float3 p)
{
	float d = BoundaryDistance(p);
	return float4(BoundaryNormal(p, d), d);
}

//-------------
// constraints

#include "HairSimComputeSolveConstraints.hlsl"

//---------
// kernels

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdatePosition(
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
{
	const uint i = worldIdx.x;
	{
		// update position
		const float4 x0 = _ParticlePositionPrev[i];
		const float4 v0 = _ParticleVelocityPrev[i];
		const float4 a0 = float4(0.0, _Gravity, 0.0, 0.0) + float4(ParticleVolumeForce(i), 0.0);
		_ParticlePosition[i] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// update positions
	{
		_ParticlePosition[strandParticleBegin] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0));

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float4 x0 = _ParticlePositionPrev[i];
			const float4 v0 = _ParticleVelocityPrev[i] + float4(ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction), 0.0);
			const float4 a0 = float4(0.0, _Gravity, 0.0, 0.0) + float4(ParticleVolumeForce(i), 0.0);
			_ParticlePosition[i] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		// solve collision constraints
		///*
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p = _ParticlePosition[i].xyz;

				ApplyCollisionConstraint(p);

				_ParticlePosition[i].xyz = p;
			}
		}//*/

		// solve distance constraints
		///*
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.0, 1.0, p0, p1);

			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}//*/

		// solve triangle bending constraints
		// https://pdfs.semanticscholar.org/759f/e17efeb59ab2081135db3d1517093bbcb085.pdf
		///*
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

			//      p1 <-- solve
			//     /
			//--- p0 (fixed)
			//    |
			//    r0 (below)
			ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 (fixed)
			//    |
			//    ## (below)
			ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ## (fixed)
				//    |
				//    ## (below)
				ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}//*/

		// solve distance constraints along strand (FTL)
		// https://matthias-research.github.io/pages/publications/FTLHairFur.pdf
		///*
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(_StrandParticleInterval, p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionCorr[i - strandParticleStride].xyz += d1;

				p0 = p1;
			}
		}//*/
	}

	// derive velocity from effective change in position
	{
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticleVelocity[i] = (_ParticlePosition[i] - _ParticlePositionPrev[i] - _DampingFTL * _ParticlePositionCorr[i]) / _DT;
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// update position
	{
		_ParticlePosition[strandParticleBegin] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0));

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float4 x0 = _ParticlePositionPrev[i];
			const float4 v0 = _ParticleVelocityPrev[i] + float4(ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction), 0.0);
			const float4 a0 = float4(0.0, _Gravity, 0.0, 0.0) + float4(ParticleVolumeForce(i), 0.0);
			_ParticlePosition[i] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
		float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
		float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
		float3 r0 = p0 - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

		//      p1 <-- solve
		//     /
		//--- p0 (fixed)
		//    |
		//    r0 (below)
		ApplyCollisionConstraint(p1);
		ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.0, 1.0, p0, p1);
		ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 0.0, 1.0, r0, p0, p1);

		//      p2 <-- solve
		//     /
		//    p1 <-- solve
		//    |
		//--- p0 (fixed)
		//    |
		//    ## (below)
		ApplyCollisionConstraint(p2.xyz);
		ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.5, 0.5, p1.xyz, p2.xyz);
		ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 1.0, 1.0, p0, p1, p2);

		for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
		{
			r0 = p0;
			p0 = p1;
			p1 = p2;
			p2 = _ParticlePosition[i].xyz;

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//    p0 <-- solve
			//    |
			//--- ## (fixed)
			//    |
			//    ## (below)
			ApplyCollisionConstraint(p2);
			ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.5, 0.5, p1, p2);
			ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 1.0, 1.0, 1.0, p0, p1, p2);

			float3 d0 = 0.0;
			ApplyDistanceFTLConstraint(_StrandParticleInterval, r0, p0, d0);

			_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			_ParticlePositionCorr[i - strandParticleStride * 3].xyz += d0;
		}

		float3 d1 = 0.0;
		float3 d2 = 0.0;
		ApplyDistanceFTLConstraint(_StrandParticleInterval, p0, p1, d1);
		ApplyDistanceFTLConstraint(_StrandParticleInterval, p1, p2, d2);

		_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
		_ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz += d1;

		_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		_ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz += d2;
	}

	// derive velocity from effective change in position
	{
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticleVelocity[i] = (_ParticlePosition[i] - _ParticlePositionPrev[i] - _DampingFTL * _ParticlePositionCorr[i]) / _DT;
		}
	}
}

groupshared float3 gs_x[THREAD_GROUP_SIZE];
groupshared float3 gs_d[THREAD_GROUP_SIZE];

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = groupIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;

	// clear corrections
	{
		gs_d[threadIdx] = 0;
	}

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction);
	const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeForce(i);
	{
		if (threadIdx == 0)
			gs_x[threadIdx] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0)).xyz;
		else
			gs_x[threadIdx] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
	}

	// solve constraints by Jacobi iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			uint n = 0;
			float3 d = 0;

			// solve collision constraints
			///*
			{
				SolveCollisionConstraint(gs_x[threadIdx], d); n++;
			}//*/

			// solve distance constraints
			///*
			{
				float3 nop = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx == 1)
				{
					SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.0, 1.0, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
				}
				else
				{
					SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.5, 0.5, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					
					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
					}
				}

				d += sum * kStiffness;
				n += count;
			}//*/

			// solve triangle bending constraints
			///*
			{
				float3 nop1 = 0;
				float3 nop2 = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx <= 1)
				{
					const uint j = threadIdx;
					const float3 gs_x_rooted = gs_x[0] - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 0.0, 0.0, 1.0, gs_x_rooted, gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;
					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 0.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
				}
				else
				{
					const uint j = threadIdx;

					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					}

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
					}
				}

				d += sum * kStiffness;
				n += count;
			}//*/

			// solve distance constraints along strand (FTL)
			float3 d_pre_ftl = d;
			SolveDistanceFTLConstraint(_StrandParticleInterval, gs_x[threadIdx - 1], gs_x[threadIdx], d); n++;
			//TODO divide the delta early to reduce averaging of FTL constraint?

			float inv_n = _Inference / n;
			gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
			gs_d[threadIdx - 1] += (d - d_pre_ftl) * inv_n;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[threadIdx];
		_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0 - _DampingFTL * gs_d[threadIdx]) / _DT;
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdateVelocity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint i = worldIdx.x;
	{
		// derive velocity from change in position
		_ParticleVelocity[i] = (_ParticlePosition[i] - _ParticlePositionPrev[i]) / _DT;
	}
}
