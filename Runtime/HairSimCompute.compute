#pragma kernel KUpdatePosition							THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128
#pragma kernel KUpdateVelocity							THREAD_GROUP_SIZE=64

#include "HairSimComputeConfig.hlsl"

float4x4 _LocalToWorld;
float4x4 _LocalToWorldInvT;

uint _StrandCount;
uint _StrandParticleCount;
float _StrandParticleInterval;

float _DT;
uint _Iterations;
float _Inference;
float _Stiffness;
float _Damping;
float _Gravity;
float _Repulsion;
float _Friction;

float _BendingCurvature;
float _BendingRestRadius;
float _DampingFTL;

StructuredBuffer<float4> _RootPosition;
StructuredBuffer<float4> _RootTangent;

RWStructuredBuffer<float4> _ParticlePosition;
RWStructuredBuffer<float4> _ParticlePositionTemp;
RWStructuredBuffer<float4> _ParticleVelocity;

StructuredBuffer<float4> _ParticlePositionPrev;
StructuredBuffer<float4> _ParticleVelocityPrev;

//--------
// volume

float3 _VolumeCells;
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;

Texture3D<int> _VolumeDensity;
Texture3D<int> _VolumeVelocityX;
Texture3D<int> _VolumeVelocityY;
Texture3D<int> _VolumeVelocityZ;
Texture3D<float3> _VolumeGradient;
SamplerState sampler_VolumeGradient;

float3 ParticleVolumePosition(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 worldPosClamped = clamp(worldPos, _VolumeWorldMin, _VolumeWorldMax);
	float3 localPos = (worldPosClamped - _VolumeWorldMin) * ((_VolumeCells - 1) / (_VolumeWorldMax - _VolumeWorldMin));
	return localPos;
}

uint3 ParticleVolumeIndex(uint i)
{
	float3 localPos = ParticleVolumePosition(i);
	float3 localPosQuantized = round(localPos);
	return localPosQuantized;
}

float3 ParticleVolumeForce(uint i)
{
#if 1
	float3 volumeUVW = ParticleVolumePosition(i) / (_VolumeCells - 1);
	float3 volumeGradient = _VolumeGradient.SampleLevel(sampler_VolumeGradient, volumeUVW, 0);
	return volumeGradient * _Repulsion;
#else
	uint3 volumeIdx = ParticleVolumeIndex(i);
	float3 volumeGradient = _VolumeGradient[volumeIdx];
	return volumeGradient * _Repulsion;
#endif
}

float3 ParticleVolumeFrictionImpulse(uint i, float3 velocity, float friction)
{
	uint3 volumeIdx = ParticleVolumeIndex(i);
	int volumeDensity = 1 + _VolumeDensity[volumeIdx];

	float3 volumeVelocity = float3(
		_VolumeVelocityX[volumeIdx],
		_VolumeVelocityY[volumeIdx],
		_VolumeVelocityZ[volumeIdx]) / (float)(1 + volumeDensity);
		
	return (volumeVelocity - velocity) * friction;
}

//------------
// boundaries

uint _BoundaryCapsuleCount;
uint _BoundarySphereCount;
uint _BoundaryTorusCount;

struct BoundaryCapsule { float3 positionA; float radius; float3 positionB; float __pad; };
struct BoundarySphere { float3 position; float radius; };
struct BoundaryTorus { float3 position; float radiusA; float3 axis; float radiusB; };

StructuredBuffer<BoundaryCapsule> _BoundaryCapsule;
StructuredBuffer<BoundarySphere> _BoundarySphere;
StructuredBuffer<BoundaryTorus> _BoundaryTorus;

//TODO
//cbuffer BoundaryCBuf
//{
//	BoundaryCapsule _BoundaryCapsule[MAX_BOUNDARIES];
//	BoundarySphere _BoundarySphere[MAX_BOUNDARIES];
//	BoundaryTorus _BoundaryTorus[MAX_BOUNDARIES];
//};

float BoundaryDistance(in float3 p)
{
	float d = 1e+4;

	// capsule
	{
		for (uint k = 0; k != _BoundaryCapsuleCount; k++)
		{
			BoundaryCapsule capsule = _BoundaryCapsule[k];

			float3 pa = p - capsule.positionA;
			float3 ba = capsule.positionB - capsule.positionA;

			float h = clamp(dot(pa, ba) / dot(ba, ba), 0, 1);
			float r = capsule.radius;
			
			d = min(d, length(pa - ba * h) - r);
		}
	}

	// sphere
	{
		for (uint k = 0; k != _BoundarySphereCount; k++)
		{
			BoundarySphere sphere = _BoundarySphere[k];

			float3 a = _BoundarySphere[k].position;
			float r = _BoundarySphere[k].radius;

			d = min(d, length(a - p) - r);
		}
	}

	// torus
	{
		//TODO
	}
	
	return d;
}

float3 BoundaryNormal(in float3 p, in float d)
{
	const float eps = 1e-4;
	const float2 h = float2(eps, 0.0);
	return normalize(float3(
		BoundaryDistance(p - h.xyy) - d,
		BoundaryDistance(p - h.yxy) - d,
		BoundaryDistance(p - h.yyx) - d
	));
}

float3 BoundaryNormal(in float3 p)
{
	return BoundaryNormal(p, BoundaryDistance(p));
}

float4 BoundaryNormalDistance(in float3 p)
{
	float d = BoundaryDistance(p);
	return float4(BoundaryNormal(p, d), d);
}

//-------------
// constraints

void ApplyCollisionConstraintDelta(in float3 p, inout float3 d)
{
	float4 P = BoundaryNormalDistance(p);
	if (P.w < 0.0)
	{
		d += P.xyz * P.w;
	}
}

void ApplyCollisionConstraint(inout float3 p)
{
	float4 P = BoundaryNormalDistance(p);
	if (P.w < 0.0)
	{
		p += P.xyz * P.w;
	}
}

void ApplyDistanceConstraintDelta(const float w0, const float w1, in float3 p0, in float3 p1, inout float3 d0, inout float3 d1)
{
	float3 r = p1 - p0;
	float rd_inv = rsqrt(dot(r, r));

	r *= 1.0 - (_StrandParticleInterval * rd_inv);

	d0 += r * w0;
	d1 -= r * w1;
}

void ApplyDistanceConstraint(const float stiffness, const float w0, const float w1, inout float3 p0, inout float3 p1)
{
	float3 r = p1 - p0;
	float rd_inv = rsqrt(dot(r, r));

	r *= 1.0 - (_StrandParticleInterval * rd_inv);

	p0 += r * w0 * stiffness;
	p1 -= r * w1 * stiffness;
}

void ApplyLRAConstraintDelta(const float range, in float3 p0, in float3 p1, inout float3 d1)
{
	float3 r = p0 - p1;
	float rd = length(r);

	if (rd > range)
	{
		r *= 1.0 - (range / rd);
		d1 += r;
	}
}

void ApplyFTLConstraintDelta(in float3 p0, in float3 p1, inout float3 d1)
{
	float3 r = p0 - p1;
	float rd_inv = rsqrt(dot(r, r));

	r *= 1.0 - (_StrandParticleInterval * rd_inv);

	d1 += r;
}

void ApplyFTLConstraint(in float3 p0, inout float3 p1, inout float3 d1)
{
	float3 r = p0 - p1;
	float rd_inv = rsqrt(dot(r, r));

	r *= 1.0 - (_StrandParticleInterval * rd_inv);

	p1 += r;
	d1 += r;
}

void ApplyTriangleBendingConstraintDelta(const float w0, const float wv, const float w1, in float3 b0, in float3 v, in float3 b1, inout float3 d0, inout float3 dv, inout float3 d1)
{
	const float K = _BendingCurvature;
	const float h0 = _BendingRestRadius;

	float3 c = (b0 + b1 + v) / 3.0;
	float3 r = v - c;
	float rd = length(r);

	float C = rd - (K + h0);
	if (C >= 0.0)// inverted to minimize bend
	{
		float dif = 1.0 - (K + h0) / rd;

		const float Winv = 1.0 / (w0 + w1 + 2.0 * wv);

		d0 += ( 2.0 * w0 * Winv * dif) * r;
		dv += (-4.0 * wv * Winv * dif) * r;
		d1 += ( 2.0 * w1 * Winv * dif) * r;
	}
}

void ApplyTriangleBendingConstraint(const float stiffness, const float w0, const float wv, const float w1, inout float3 b0, inout float3 v, inout float3 b1)
{
	const float K = _BendingCurvature;
	const float h0 = _BendingRestRadius;

	float3 c = (b0 + b1 + v) / 3.0;
	float3 r = (v - c);
	float rd = length(r);

	float C = rd - (K + h0);
	if (C >= 0.0)// inverted to minimize bend
	{
		float dif = 1.0 - (K + h0) / rd;

		const float Winv = 1.0 / (w0 + w1 + 2.0 * wv);

		float3 d0 = ( 2.0 * w0 * Winv * dif) * r;
		float3 dv = (-4.0 * wv * Winv * dif) * r;
		float3 d1 = ( 2.0 * w1 * Winv * dif) * r;

		b0 += stiffness * d0;
		v  += stiffness * dv;
		b1 += stiffness * d1;
	}
}

//---------
// kernels

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdatePosition(
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
{
	const uint i = worldIdx.x;
	{
		// update position
		const float4 x0 = _ParticlePositionPrev[i];
		const float4 v0 = _ParticleVelocityPrev[i];
		const float4 a0 = float4(0.0, _Gravity, 0.0, 0.0) + float4(ParticleVolumeForce(i), 0.0);
		_ParticlePosition[i] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionTemp[i] = 0;
		}
	}

	// update positions
	{
		_ParticlePosition[strandParticleBegin] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0));

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float4 x0 = _ParticlePositionPrev[i];
			const float4 v0 = _ParticleVelocityPrev[i];
			const float4 a0 = float4(0.0, _Gravity, 0.0, 0.0) + float4(ParticleVolumeForce(i), 0.0);
			_ParticlePosition[i] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		// solve collision constraints
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p = _ParticlePosition[i].xyz;

				ApplyCollisionConstraint(p);

				_ParticlePosition[i].xyz = p;
			}
		}

		// solve distance constraints
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(kStiffness, 0.0, 1.0, p0, p1);

			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(kStiffness, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve bending constraints
		// https://pdfs.semanticscholar.org/759f/e17efeb59ab2081135db3d1517093bbcb085.pdf
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

			//      p1 <-- solve
			//     /
			//--- p0 (fixed)
			//    |
			//    r0 (below)
			ApplyTriangleBendingConstraint(kStiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 (fixed)
			//    |
			//    ## (below)
			ApplyTriangleBendingConstraint(kStiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ## (fixed)
				//    |
				//    ## (below)
				ApplyTriangleBendingConstraint(kStiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}

		// solve distance constraints along strand (FTL)
		// https://matthias-research.github.io/pages/publications/FTLHairFur.pdf
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyFTLConstraint(p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionTemp[i - strandParticleStride].xyz += d1;

				p0 = p1;
			}
		}
	}

	// derive velocity from effective change in position
	{
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticleVelocity[i] = (_ParticlePosition[i] - _ParticlePositionPrev[i] - _DampingFTL * _ParticlePositionTemp[i]) / _DT;
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionTemp[i] = 0;
		}
	}

	// update position
	{
		_ParticlePosition[strandParticleBegin] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0));

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float4 x0 = _ParticlePositionPrev[i];
			const float4 v0 = _ParticleVelocityPrev[i];
			const float4 a0 = float4(0.0, _Gravity, 0.0, 0.0) + float4(ParticleVolumeForce(i), 0.0);
			_ParticlePosition[i] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
		float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
		float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
		float3 r0 = p0 - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

		//      p1 <-- solve
		//     /
		//--- p0 (fixed)
		//    |
		//    r0 (below)
		ApplyCollisionConstraint(p1);
		ApplyDistanceConstraint(kStiffness, 0.0, 1.0, p0, p1);
		ApplyTriangleBendingConstraint(kStiffness, 0.0, 0.0, 1.0, r0, p0, p1);

		//      p2 <-- solve
		//     /
		//    p1 <-- solve
		//    |
		//--- p0 (fixed)
		//    |
		//    ## (below)
		ApplyCollisionConstraint(p2.xyz);
		ApplyDistanceConstraint(kStiffness, 0.5, 0.5, p1.xyz, p2.xyz);
		ApplyTriangleBendingConstraint(kStiffness, 0.0, 1.0, 1.0, p0, p1, p2);

		for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
		{
			r0 = p0;
			p0 = p1;
			p1 = p2;
			p2 = _ParticlePosition[i].xyz;

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//    p0 <-- solve
			//    |
			//--- ## (fixed)
			//    |
			//    ## (below)
			ApplyCollisionConstraint(p2);
			ApplyDistanceConstraint(kStiffness, 0.5, 0.5, p1, p2);
			ApplyTriangleBendingConstraint(kStiffness, 1.0, 1.0, 1.0, p0, p1, p2);

			float3 d0 = 0;
			ApplyFTLConstraint(r0, p0, d0);

			_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			_ParticlePositionTemp[i - strandParticleStride * 3].xyz += d0;
		}

		float3 d1 = 0;
		ApplyFTLConstraint(p0, p1, d1);
		float3 d2 = 0;
		ApplyFTLConstraint(p1, p2, d2);

		_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
		_ParticlePositionTemp[strandParticleEnd - strandParticleStride * 3].xyz += d1;
		_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		_ParticlePositionTemp[strandParticleEnd - strandParticleStride * 2].xyz += d2;
	}

	// derive velocity from effective change in position
	{
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticleVelocity[i] = (_ParticlePosition[i] - _ParticlePositionPrev[i] - _DampingFTL * _ParticlePositionTemp[i]) / _DT;
		}
	}
}

groupshared float3 gs_x[THREAD_GROUP_SIZE];
groupshared float3 gs_d[THREAD_GROUP_SIZE];

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = groupIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;

	// clear corrections
	{
		gs_d[threadIdx] = 0;
	}

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction);
	const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeForce(i);
	{
		if (threadIdx == 0)
			gs_x[threadIdx] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0)).xyz;
		else
			gs_x[threadIdx] = x0 + (_DT * pow(max(1e-4, 1.0 - _Damping), _DT)) * (v0 + _DT * a0);
	}

	// solve constraints by Jacobi iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			uint n = 0;
			float3 d = 0;
			ApplyCollisionConstraintDelta(gs_x[threadIdx], d); n++;

			///*
			{
				ApplyLRAConstraintDelta(threadIdx * _StrandParticleInterval, gs_x[0], gs_x[threadIdx], d); n++;
			}//*/

			///*
			{
				float3 nop = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx == 1)
				{
					ApplyDistanceConstraintDelta(0.0, 1.0, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					ApplyDistanceConstraintDelta(0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
				}
				else
				{
					ApplyDistanceConstraintDelta(0.5, 0.5, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					
					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						ApplyDistanceConstraintDelta(0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
					}
				}

				d += sum * kStiffness;
				n += count;
			}//*/

			///*
			{
				float3 nop1 = 0;
				float3 nop2 = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx <= 1)
				{
					const uint j = threadIdx;
					const float3 gs_x_rooted = gs_x[0] - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

					ApplyTriangleBendingConstraintDelta(0.0, 0.0, 1.0, gs_x_rooted, gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;
					ApplyTriangleBendingConstraintDelta(0.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					ApplyTriangleBendingConstraintDelta(1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
				}
				else
				{
					const uint j = threadIdx;

					ApplyTriangleBendingConstraintDelta(1.0, 1.0, 1.0, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						ApplyTriangleBendingConstraintDelta(1.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					}

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						ApplyTriangleBendingConstraintDelta(1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
					}
				}

				d += sum * kStiffness;
				n += count;
			}//*/

			//TODO divide the delta early to reduce averaging of FTL constraint?
			float3 d_pre_ftl = d;
			//ApplyFTLConstraintDelta(gs_x[threadIdx - 1], gs_x[threadIdx], d); n++;

			float inv_n = _Inference / n;
			gs_d[threadIdx - 1] += (d - d_pre_ftl) * inv_n;
			gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
		}
	}
	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[threadIdx];
		_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0/* - _DampingFTL * gs_d[threadIdx]*/) / _DT;
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdateVelocity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint i = worldIdx.x;
	{
		// derive velocity from change in position
		_ParticleVelocity[i] = (_ParticlePosition[i] - _ParticlePositionPrev[i]) / _DT;
	}
}
