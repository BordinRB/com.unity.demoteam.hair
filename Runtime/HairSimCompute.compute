#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128
#pragma kernel KUpdatePosition							THREAD_GROUP_SIZE=64
#pragma kernel KUpdateVelocity							THREAD_GROUP_SIZE=64

#define ENABLE_VOLUME_FRICTION			1
#define ENABLE_VOLUME_REPULSION			1

#define ENABLE_CONSTRAINT_COLLISION		1
#define ENABLE_CONSTRAINT_DISTANCE		1
#define ENABLE_CONSTRAINT_CURVATURE		1
#define ENABLE_CONSTRAINT_FTL			1

#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverConstraints.hlsl"

//----------
// uniforms

float4x4 _LocalToWorld;
float4x4 _LocalToWorldInvT;

uint _StrandCount;
uint _StrandParticleCount;
float _StrandParticleInterval;

float _DT;
uint _Iterations;
float _Stiffness;
float _Inference;
float _Damping;
float _Gravity;
float _Repulsion;
float _Friction;

float _BendingCurvature;
float _BendingStiffness;
float _DampingFTL;

StructuredBuffer<float4> _RootPosition;
StructuredBuffer<float4> _RootTangent;

StructuredBuffer<float4> _ParticlePositionPrev;
StructuredBuffer<float4> _ParticleVelocityPrev;

RWStructuredBuffer<float4> _ParticlePosition;
RWStructuredBuffer<float4> _ParticlePositionCorr;
RWStructuredBuffer<float4> _ParticleVelocity;

float3 _VolumeCells;
float3 _VolumeWorldMin;
float3 _VolumeWorldMax;

Texture3D<int> _VolumeDensity;
Texture3D<float3> _VolumeVelocity;
Texture3D<float3> _VolumeGradient;
SamplerState sampler_VolumeVelocity;
SamplerState sampler_VolumeGradient;

//----------
// indexing

float3 ParticleVolumePosition(uint i)
{
	float3 worldPos = _ParticlePosition[i].xyz;
	float3 localUVW = (worldPos - _VolumeWorldMin) / (_VolumeWorldMax - _VolumeWorldMin);
	float3 localPos = (_VolumeCells - 1) * saturate(localUVW);
	return localPos;

	//float3 worldPos = _ParticlePosition[i].xyz;
	//float3 worldPosClamped = clamp(worldPos, _VolumeWorldMin, _VolumeWorldMax);
	//float3 localPos = (worldPosClamped - _VolumeWorldMin) * ((_VolumeCells - 1) / (_VolumeWorldMax - _VolumeWorldMin));
	//return localPos;
}

uint3 ParticleVolumeIndex(uint i)
{
	float3 localPos = ParticleVolumePosition(i);
	float3 localPosQuantized = round(localPos);
	return localPosQuantized;
}

float3 ParticleVolumeFrictionImpulse(uint i, float3 velocity, float friction)
{
	if (ENABLE_VOLUME_FRICTION)
	{
		float3 volumeUVW = ParticleVolumePosition(i) / (_VolumeCells - 1);
		float3 volumeVelocity = _VolumeVelocity.SampleLevel(sampler_VolumeVelocity, volumeUVW, 0);
		return (volumeVelocity - velocity) * friction;
	}
	else
	{
		return 0.0;
	}
}

float3 ParticleVolumeRepulsionForce(uint i)
{
	if (ENABLE_VOLUME_REPULSION)
	{
		float3 volumeUVW = ParticleVolumePosition(i) / (_VolumeCells - 1);
		float3 volumeGradient = _VolumeGradient.SampleLevel(sampler_VolumeGradient, volumeUVW, 0);
		return volumeGradient * _Repulsion;
	}
	else
	{
		return 0.0;
	}
}

//---------
// utility

float GetDecay()
{
	return pow(max(1e-4, 1.0 - _Damping), _DT);
}

float3 Integrate(float3 x0, float3 v0, float3 a0)
{
	return x0 + (_DT * GetDecay()) * (v0 + _DT * a0);
}

//---------
// kernels

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	if (ENABLE_CONSTRAINT_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i].xyz = 0;
		}
	}

	// update positions
	{
		_ParticlePosition[strandParticleBegin].xyz = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0)).xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction);
			const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeRepulsionForce(i);
			{
				_ParticlePosition[i].xyz = Integrate(x0, v0, a0);
			}
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		// solve collision constraints
		if (ENABLE_CONSTRAINT_COLLISION)
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				ApplyCollisionConstraint(_ParticlePosition[i].xyz);
			}
		}

		// solve distance constraints
		if (ENABLE_CONSTRAINT_DISTANCE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.0, 1.0, p0, p1);

			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve triangle bending constraints
		if (ENABLE_CONSTRAINT_CURVATURE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

			//      p1 <-- solve
			//     /
			//--- p0 (fixed)
			//    |
			//    r0 (below)
			ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 (fixed)
			//    |
			//    ## (below)
			ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ## (fixed)
				//    |
				//    ## (below)
				ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}

		// solve distance constraints along strand (FTL)
		if (ENABLE_CONSTRAINT_FTL)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(_StrandParticleInterval, p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionCorr[i - strandParticleStride].xyz += d1;

				p0 = p1;
			}
		}
	}

	// derive velocity from effective change in position
	{
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_CONSTRAINT_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _DampingFTL * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	if (ENABLE_CONSTRAINT_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// update position
	{
		_ParticlePosition[strandParticleBegin] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0));

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction);
			const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeRepulsionForce(i);
			{
				_ParticlePosition[i].xyz = Integrate(x0, v0, a0);
			}
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
		float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
		float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
		float3 r0 = p0 - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

		//      p1 <-- solve
		//     /
		//--- p0 (fixed)
		//    |
		//    r0 (below)
		if (ENABLE_CONSTRAINT_COLLISION)	ApplyCollisionConstraint(p1);
		if (ENABLE_CONSTRAINT_DISTANCE)		ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.0, 1.0, p0, p1);
		if (ENABLE_CONSTRAINT_CURVATURE)	ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 0.0, 1.0, r0, p0, p1);
		
		//      p2 <-- solve
		//     /
		//    p1 <-- solve
		//    |
		//--- p0 (fixed)
		//    |
		//    ## (below)
		if (ENABLE_CONSTRAINT_COLLISION)	ApplyCollisionConstraint(p2);
		if (ENABLE_CONSTRAINT_DISTANCE)		ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.5, 0.5, p1, p2);
		if (ENABLE_CONSTRAINT_CURVATURE)	ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 0.0, 1.0, 1.0, p0, p1, p2);

		for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
		{
			r0 = p0;
			p0 = p1;
			p1 = p2;
			p2 = _ParticlePosition[i].xyz;

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//    p0 <-- solve
			//    |
			//--- ## (fixed)
			//    |
			//    ## (below)
			if (ENABLE_CONSTRAINT_COLLISION)	ApplyCollisionConstraint(p2);
			if (ENABLE_CONSTRAINT_DISTANCE)		ApplyDistanceConstraint(_StrandParticleInterval, kStiffness, 0.5, 0.5, p1, p2);
			if (ENABLE_CONSTRAINT_CURVATURE)	ApplyTriangleBendingConstraint(_BendingCurvature, kStiffness, 1.0, 1.0, 1.0, p0, p1, p2);
			
			if (ENABLE_CONSTRAINT_FTL)
			{
				float3 d0 = 0.0;
				ApplyDistanceFTLConstraint(_StrandParticleInterval, r0, p0, d0);

				_ParticlePositionCorr[i - strandParticleStride * 3].xyz += d0;
			}

			_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
		}

		if (ENABLE_CONSTRAINT_FTL)
		{
			float3 d1 = 0.0;
			float3 d2 = 0.0;
			ApplyDistanceFTLConstraint(_StrandParticleInterval, p0, p1, d1);
			ApplyDistanceFTLConstraint(_StrandParticleInterval, p1, p2, d2);

			_ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz += d1;
			_ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz += d2;
		}

		_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
		_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
	}

	// derive velocity from effective change in position
	{
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_CONSTRAINT_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _DampingFTL * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

#define NEW_JACOBI 1
#if NEW_JACOBI
groupshared float4 gs_x[THREAD_GROUP_SIZE + 1];// pad head
groupshared float3 gs_d[THREAD_GROUP_SIZE + 1];// pad head
#else
groupshared float3 gs_x[THREAD_GROUP_SIZE];
groupshared float3 gs_d[THREAD_GROUP_SIZE];
#endif

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = groupIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;
#if NEW_JACOBI

	const uint j = threadIdx + 1;

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	{
		if (threadIdx == 0)
		{
			const float3 rootPosition = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0)).xyz;
			const float3 rootTangent = mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz;
			{
				gs_x[0] = float4(rootPosition - rootTangent * _StrandParticleInterval, 0.0);
				gs_x[1] = float4(rootPosition, 0.0);
			}
		}
		else
		{
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction);
			const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeRepulsionForce(i);
			{
				gs_x[j] = float4(Integrate(x0, v0, a0), 1.0);
				gs_d[j] = 0.0;
			}
		}
	}

	// solve constraints by Jacobi iteration
	const uint m = (THREAD_GROUP_SIZE - 1) - threadIdx;
	const uint n = (
		ENABLE_CONSTRAINT_COLLISION +
		ENABLE_CONSTRAINT_DISTANCE * min(2, 1 + m) +
		ENABLE_CONSTRAINT_CURVATURE * min(3, 1 + m) +
		ENABLE_CONSTRAINT_FTL
		);
	
	const float n_inv = _Inference / n;
	float3 d_ftl = 0;

	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			float3 d = 0.0;

			// solve collision constraints
			if (ENABLE_CONSTRAINT_COLLISION)
			{
				SolveCollisionConstraint(gs_x[j].xyz, d);
			}

			// solve distance constraints
			if (ENABLE_CONSTRAINT_DISTANCE)
			{
				float3 nop = 0;

				SolveDistanceConstraint(_StrandParticleInterval, kStiffness, gs_x[j - 1], gs_x[j], nop, d);

				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveDistanceConstraint(_StrandParticleInterval, kStiffness, gs_x[j], gs_x[j + 1], d, nop);
				}
			}

			// solve triangle bending constraints
			if (ENABLE_CONSTRAINT_CURVATURE)
			{
				float3 nop = 0;

				SolveTriangleBendingConstraint(_BendingCurvature, kStiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop, nop, d);

				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveTriangleBendingConstraint(_BendingCurvature, kStiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop, d, nop);

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveTriangleBendingConstraint(_BendingCurvature, kStiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], d, nop, nop);
					}
				}
			}

			// solve distance constraints along strand (FTL)
			if (ENABLE_CONSTRAINT_FTL)
			{
				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_pre_ftl = d;
				SolveDistanceFTLConstraint(_StrandParticleInterval, gs_x[j - 1].xyz, gs_x[j].xyz, d);
				d_ftl += (d - d_pre_ftl) * n_inv;
			}

			// move to next iteration
			gs_x[j].xyz += d * n_inv;
		}
	}

	if (ENABLE_CONSTRAINT_FTL)
	{
		gs_d[j - 1] = d_ftl;
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[j].xyz;

		if (ENABLE_CONSTRAINT_FTL)
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0 - _DampingFTL * gs_d[j]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0) / _DT;
	}

#else
	//---------------------------------- ORIGINAL -----------------------------

	// clear corrections
	if (ENABLE_CONSTRAINT_FTL)
	{
		gs_d[threadIdx] = 0;
	}

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeFrictionImpulse(i, _ParticleVelocityPrev[i].xyz, _Friction);
	const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeRepulsionForce(i);
	{
		if (threadIdx == 0)
			gs_x[threadIdx] = mul(_LocalToWorld, float4(_RootPosition[strandIndex].xyz, 1.0)).xyz;
		else
			gs_x[threadIdx] = Integrate(x0, v0, a0);
	}

	// solve constraints by Jacobi iteration
	for (uint __iter = 0; __iter != _Iterations; __iter++)
	{
		const float kStiffness = 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (__iter + 1));

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			uint n = 0;
			float3 d = 0;

			// solve collision constraints
			if (ENABLE_CONSTRAINT_COLLISION)
			{
				SolveCollisionConstraint(gs_x[threadIdx], d); n++;
			}

			// solve distance constraints
			if (ENABLE_CONSTRAINT_DISTANCE)
			{
				float3 nop = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx == 1)
				{
					SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.0, 1.0, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
				}
				else
				{
					SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.5, 0.5, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					
					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveDistanceConstraint(_StrandParticleInterval, 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
					}
				}

				d += sum * kStiffness;
				n += count;
			}

			// solve triangle bending constraints
			if (ENABLE_CONSTRAINT_CURVATURE)
			{
				float3 nop1 = 0;
				float3 nop2 = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx <= 1)
				{
					const uint j = threadIdx;
					const float3 gs_x_rooted = gs_x[0] - mul(_LocalToWorldInvT, float4(_RootTangent[strandIndex].xyz, 0.0)).xyz * _StrandParticleInterval;

					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 0.0, 0.0, 1.0, gs_x_rooted, gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;
					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 0.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
				}
				else
				{
					const uint j = threadIdx;

					SolveTriangleBendingConstraint(_BendingCurvature, 1.0, threadIdx != 2 ? 1.0 : 0.0, 1.0, 1.0, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					}

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
					}
				}

				d += sum * kStiffness;
				n += count;
			}

			// solve distance constraints along strand (FTL)
			if (ENABLE_CONSTRAINT_FTL)
			{
				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_pre_ftl = d;
				SolveDistanceFTLConstraint(_StrandParticleInterval, gs_x[threadIdx - 1], gs_x[threadIdx], d); n++;

				float inv_n = _Inference / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
				gs_d[threadIdx - 1] += (d - d_pre_ftl) * inv_n;
			}
			else
			{
				float inv_n = _Inference / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[threadIdx];

		if (ENABLE_CONSTRAINT_FTL)
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0 - _DampingFTL * gs_d[threadIdx]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0) / _DT;
	}
#endif
}


[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdatePosition(
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
{
	const uint i = worldIdx.x;
	{
		// update position
		const float3 x0 = _ParticlePositionPrev[i].xyz;
		const float3 v0 = _ParticleVelocityPrev[i].xyz;
		const float3 a0 = float3(0.0, _Gravity, 0.0) + ParticleVolumeRepulsionForce(i);

		_ParticlePosition[i].xyz = Integrate(x0, v0, a0);
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdateVelocity(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint i = worldIdx.x;
	{
		// derive velocity from change in position
		_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
	}
}
