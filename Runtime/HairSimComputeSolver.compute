#pragma kernel KInitParticles							THREAD_GROUP_SIZE=64
#pragma kernel KInitParticlesPostVolume					THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128

//----------
// features

#pragma multi_compile __ LAYOUT_INTERLEAVED
// 0 == particles grouped by strand, i.e. root, root+1, root, root+1
// 1 == particles grouped by index, i.e. root, root, root+1, root+1

#pragma multi_compile __ ENABLE_BOUNDARY ENABLE_BOUNDARY_FRICTION
#pragma multi_compile __ ENABLE_DISTANCE
#pragma multi_compile __ ENABLE_DISTANCE_LRA
#pragma multi_compile __ ENABLE_DISTANCE_FTL
#pragma multi_compile __ ENABLE_CURVATURE_EQ ENABLE_CURVATURE_GEQ ENABLE_CURVATURE_LEQ
#pragma multi_compile __ ENABLE_POSE_LOCAL_BEND_TWIST
#pragma multi_compile __ ENABLE_POSE_GLOBAL_POSITION
#pragma multi_compile __ ENABLE_POSE_GLOBAL_ROTATION

#ifndef ENABLE_BOUNDARY
#define ENABLE_BOUNDARY 0
#endif
#ifndef ENABLE_BOUNDARY_FRICTION
#define ENABLE_BOUNDARY_FRICTION 0
#endif
#ifndef ENABLE_DISTANCE
#define ENABLE_DISTANCE 0
#endif
#ifndef ENABLE_DISTANCE_LRA
#define ENABLE_DISTANCE_LRA 0
#endif
#ifndef ENABLE_DISTANCE_FTL
#define ENABLE_DISTANCE_FTL 0
#endif
#ifndef ENABLE_CURVATURE_EQ
#define ENABLE_CURVATURE_EQ 0
#endif
#ifndef ENABLE_CURVATURE_GEQ
#define ENABLE_CURVATURE_GEQ 0
#endif
#ifndef ENABLE_CURVATURE_LEQ
#define ENABLE_CURVATURE_LEQ 0
#endif
#ifndef ENABLE_POSE_LOCAL_BEND_TWIST
#define ENABLE_POSE_LOCAL_BEND_TWIST 0
#endif
#ifndef ENABLE_POSE_GLOBAL_POSITION
#define ENABLE_POSE_GLOBAL_POSITION 0
#endif
#ifndef ENABLE_POSE_GLOBAL_ROTATION
#define ENABLE_POSE_GLOBAL_ROTATION 0
#endif

#define ENABLE_VOLUME_PRESSURE 1
#define ENABLE_VOLUME_FRICTION 1

#define SECOND_ORDER_PREDICTION 0

//----------
// includes

#define HAIRSIM_WRITEABLE_SOLVERDATA 1

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverConstraints.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

//--------
// macros

#define ENABLE_CURVATURE (ENABLE_CURVATURE_EQ || ENABLE_CURVATURE_GEQ || ENABLE_CURVATURE_LEQ)

#if ENABLE_CURVATURE_GEQ
  #define ApplyTriangleBendingConstraint ApplyTriangleBendingMinConstraint
  #define SolveTriangleBendingConstraint SolveTriangleBendingMinConstraint
#elif ENABLE_CURVATURE_LEQ
  #define ApplyTriangleBendingConstraint ApplyTriangleBendingMaxConstraint
  #define SolveTriangleBendingConstraint SolveTriangleBendingMaxConstraint
#endif

#if LAYOUT_INTERLEAVED
  #define DECLARE_STRAND(x)							\
	if (x >= _StrandCount) return;					\
	const uint strandIndex = x;						\
	const uint strandParticleBegin = strandIndex;	\
	const uint strandParticleStride = _StrandCount;	\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#else
  #define DECLARE_STRAND(x)													\
	if (x >= _StrandCount) return;											\
	const uint strandIndex = x;												\
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;	\
	const uint strandParticleStride = 1;									\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#endif

#define STRAND_IDX		strandIndex
#define STRAND_BEGIN	strandParticleBegin
#define STRAND_STRIDE	strandParticleStride
#define STRAND_END		strandParticleEnd

#define STRAND_FOREACH(i, offset)				for (uint i = STRAND_BEGIN + STRAND_STRIDE * offset; i != STRAND_END; i += STRAND_STRIDE)
#define STRAND_FOREACH_NUMBERED(i, k, offset)	for (uint i = STRAND_BEGIN + STRAND_STRIDE * offset, k = offset; i != STRAND_END; i += STRAND_STRIDE, k++)

//---------
// utility

float3 ParticleVolumeImpulse(uint i, float3 velocity)
{
	float3 volumeUVW = VolumeWorldToUVW(_ParticlePositionPrev[i].xyz);

#if ENABLE_VOLUME_PRESSURE
	float3 volumePressureGradient = VolumeSampleVector(_VolumePressureGrad, volumeUVW);
	float3 volumePressureImpulse = -volumePressureGradient;// * (_DT / volumeDensity);
#else
	float3 volumePressureImpulse = 0.0;
#endif

#if ENABLE_VOLUME_FRICTION
  #if SPLAT_TRILINEAR
	float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_trilinear_clamp);
  #else
	float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_point_clamp);
  #endif
	float3 volumeVelocityImpulse = (volumeVelocity - velocity);
#else
	float3 volumeVelocityImpulse = 0.0;
#endif

	return (
		volumePressureImpulse * _CellPressure +
		volumeVelocityImpulse * _CellVelocity
	);
}

float GetDecay(float smoothing, float interval)
{
	return pow(max(1e-5, smoothing), _DT / interval);
}

float GetDampingDecay()
{
	return GetDecay(1.0 - _Damping, _DampingInterval);
}

float3 IntegratePosition(float3 x0, float3 v0, float3 a0)
{
	return x0 + _DT * (v0 * GetDampingDecay() + _DT * a0);
}

float3 IntegratePosition_SecondOrder(float3 x0, float3 x0_minus1, float3 v0, float3 v0_minus1, float3 a0)
{
	// second order prediction
	// http://www.cs.ubc.ca/~rbridson/docs/english-siggraph08-cloth.pdf

	return (
		(4.0 / 3.0) * x0 -
		(1.0 / 3.0) * x0_minus1 +
		(8.0 / 9.0) * _DT * GetDampingDecay() * v0 -
		(2.0 / 9.0) * _DT * GetDampingDecay() * v0_minus1 +
		(4.0 / 9.0) * _DT * _DT * a0
	);
}

float GetIterationStiffness(uint iteration)
{
	//return 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / _Iterations);
	return 1.0 - pow(saturate(1.0 - _Stiffness), 1.0 / (1 + iteration));
}

float GetParticleInterval(uint strandIndex)
{
	return (_StrandMaxParticleInterval * _StrandScale) * _RootScale[strandIndex];
}

float GetBendingRadius(uint strandIndex)
{
	return _LocalCurvature * GetParticleInterval(strandIndex);
}

float GetGlobalAttenuation(uint strandIndex, uint linearParticleIndex)
{
	float t = _RootScale[strandIndex] * (linearParticleIndex / (float)(_StrandParticleCount - 1));
	float k = saturate((t - _GlobalFadeOffset) / _GlobalFadeExtent);
	return 1.0 - k;
}

float GetGlobalPositionInfluence(uint strandIndex, uint linearParticleIndex)
{
	float k = _GlobalPosition * GetGlobalAttenuation(strandIndex, linearParticleIndex);
	return 1.0 - GetDecay(1.0 - k, _GlobalPositionInterval);// fits into lerp
}

float GetGlobalRotationInfluence(uint strandIndex, uint linearParticleIndex)
{
	float k = _GlobalRotation * GetGlobalAttenuation(strandIndex, linearParticleIndex);
	return k;
}

//--------------
// kernels init

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitParticles(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	// store initial pose
	//TODO move things around here

	float3 rootPos0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 rootPosWorld = _RootPosition[strandIndex].xyz;
	
	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 particleOffset0 = _ParticlePosition[i].xyz - rootPos0;
		float3 particleOffsetWorld = QMul(_WorldRotation, particleOffset0 * _StrandScale);

		_InitialParticleOffset[i].xyz = particleOffset0;

		_ParticlePosition[i].xyz = (rootPosWorld + particleOffsetWorld);
		_ParticlePositionPrev[i].xyz = (rootPosWorld + particleOffsetWorld);
		_ParticlePositionCorr[i].xyz = 0.0;
		_ParticleVelocity[i] = float4(0.0, 0.0, 0.0, _StrandMaxParticleWeight * _RootScale[strandIndex]);
		_ParticleVelocityPrev[i] = float4(0.0, 0.0, 0.0, _StrandMaxParticleWeight * _RootScale[strandIndex]);
	}

	// calc initial strand root material frame
	{
		float3 rootDir0 = normalize(_InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz);
		float3 rootDirMaterialFrame = float3(0.0, 1.0, 0.0);

		_InitialRootFrame[strandIndex] = MakeQuaternionFromTo(rootDirMaterialFrame, rootDir0);
	}

	// calc initial particle material frame deltas
	{
		float4 rootFrame = _InitialRootFrame[strandIndex];
		float4 rootFrameInv = QInverse(rootFrame);

		// root
		_InitialParticleFrameDelta[strandParticleBegin] = MakeQuaternionIdentity();//TODO might as well store root frame here?
	
		// root+1
		float3 r0 = -float3(0.0, 1.0, 0.0);
		float3 r1 = 0.0;
		float3 r2 = QMul(rootFrameInv, _InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz);
		{
			_InitialParticleFrameDelta[strandParticleBegin + strandParticleStride] = MakeQuaternionFromBend(r0, r1, r2);
		}
		
		// root+2..
		for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
		{
			r0 = r1;
			r1 = r2;
			r2 = QMul(rootFrameInv, _InitialParticleOffset[i].xyz);

			_InitialParticleFrameDelta[i] = normalize(QMul(MakeQuaternionFromBend(r0, r1, r2), _InitialParticleFrameDelta[i - strandParticleStride]));
		}

		// reverse to finalize
		{
			for (uint i = strandParticleEnd - strandParticleStride; i != strandParticleBegin; i -= strandParticleStride)
			{
				float4 q0 = _InitialParticleFrameDelta[i - strandParticleStride];
				float4 q1 = _InitialParticleFrameDelta[i];

				_InitialParticleFrameDelta[i] = normalize(QMul(QInverse(q0), q1));
			}
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitParticlesPostVolume(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);
	
	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 uvw = VolumeWorldToUVW(_ParticlePosition[i].xyz);
		float accu_w = _VolumeVelocity.SampleLevel(_Volume_trilinear_clamp, uvw, 0).w;

		//TODO comment
		if (true)
		{
			TrilinearWeights tri = VolumeWorldToCellTrilinear(_ParticlePosition[i].xyz);

			const float3 sqw0 = tri.w0 * tri.w0;
			const float3 sqw1 = tri.w1 * tri.w1;

			const float d = (
				sqw0.x * sqw0.y * sqw0.z +
				sqw1.x * sqw0.y * sqw0.z +
				sqw0.x * sqw1.y * sqw0.z +
				sqw1.x * sqw1.y * sqw0.z +
				sqw0.x * sqw0.y * sqw1.z +
				sqw1.x * sqw0.y * sqw1.z +
				sqw0.x * sqw1.y * sqw1.z +
				sqw1.x * sqw1.y * sqw1.z
				);

			accu_w = accu_w / d;
		}

		_ParticlePosition[i].w = accu_w;//TODO pack elsewhere?
		_ParticlePositionPrev[i].w = accu_w;
	}
}

//---------------
// kernels solve

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	// update positions
	{
		_ParticlePosition[strandParticleBegin].xyz = _RootPosition[strandIndex].xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
			}
		}
	}

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i].xyz = 0;
		}
	}

	// apply global position constraints
	if (ENABLE_POSE_GLOBAL_POSITION)
	{
		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			float3 r0 = _ParticlePosition[i].xyz - p0;
			float3 r1 = QMul(_WorldRotation, _InitialParticleOffset[i].xyz * _StrandScale);

			_ParticlePosition[i].xyz = p0 + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, k));
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		// solve boundary collision constraints
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, _ParticlePosition[i].xyz);
				else
					ApplyCollisionConstraint(_ParticlePosition[i].xyz);
			}
		}

		// solve particle-particle distance constraints
		if (ENABLE_DISTANCE)
		{
			// root+1
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.0, 1.0, p0, p1);

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve 'long range attachment' distance constraints
		if (ENABLE_DISTANCE_LRA)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			// root+1..
			for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				float3 p1 = _ParticlePosition[i].xyz;

				ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, p0, p1);

				_ParticlePosition[i].xyz = p1;
			}
		}

		// solve triangle bending constraints
		if (ENABLE_CURVATURE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

			//      p1 <-- solve
			//     /
			//--- p0 <-- fixed (root)
			//    |
			//    r0 <-- fixed (root-1)
			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 <-- fixed (root)
			//    |
			//    ##
			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ##
				ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}

		// solve global rotation constraints
		if (ENABLE_POSE_GLOBAL_ROTATION)
		{
			float4 rootFrame = _RootFrame[strandIndex];
			float3 rootPos = _RootPosition[strandIndex].xyz;
			float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

			// root
			float3 p0 = rootPos - rootVec;
			float3 p1 = rootPos;

			float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;

				p0 = rootPos;
				p1 = _ParticlePosition[i].xyz;

				accuFrame = QMul(accuFrame, _InitialParticleFrameDelta[i]);

				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, 1), 0.0, 1.0, 0.0, p0, p1, accuFrame);
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2, k = 2; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				accuFrame = QMul(accuFrame, _InitialParticleFrameDelta[i]);

				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), 1.0, 1.0, 0.0, p0, p1, accuFrame);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve local shape constraints
		if (ENABLE_POSE_LOCAL_BEND_TWIST)
		{
			float4 rootFrame = _RootFrame[strandIndex];
			float3 rootPos = _RootPosition[strandIndex].xyz;
			float3 rootDir = QMul(rootFrame, float3(0, 1, 0));

			// root
			float3 p0 = rootPos - rootDir * GetParticleInterval(strandIndex) * 3.0;
			float3 p1 = rootPos - rootDir * GetParticleInterval(strandIndex) * 2.0;
			float3 p2 = rootPos - rootDir * GetParticleInterval(strandIndex);
			float3 p3 = rootPos;

			float4 q2 = MakeQuaternionIdentity();
			float4 q3 = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;

				p0 = p1;// root-2
				p1 = p2;// root-1
				p2 = p3;// root
				p3 = _ParticlePosition[i].xyz;

				q2 = q3;// root frame
				q3 = QMul(MakeQuaternionFromBend(p1, p2, p3), q2);

				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, 0.0f, 1.0f, q2, q3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 0.0f, 1.0f, 1.0f, p2, p3, q3);
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = p3;
				p3 = _ParticlePosition[i].xyz;

				q2 = q3;
				q3 = QMul(MakeQuaternionFromBend(p1, p2, p3), q2);

				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, 1.0f, 1.0f, q2, q3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 1.0f, 1.0f, 1.0f, p2, p3, q3);

				_ParticlePosition[i - strandParticleStride].xyz = p2;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p3;
		}

		// solve 'follow the leader' distance constraints
		if (ENABLE_DISTANCE_FTL)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionCorr[i - strandParticleStride].xyz += d1;// correction to particle above current particle

				p0 = p1;
			}
		}
	}

	// derive velocity from effective change in position
	{
		// root
		_ParticleVelocity[strandParticleBegin].xyz = (_ParticlePosition[strandParticleBegin].xyz - _ParticlePositionPrev[strandParticleBegin].xyz) / _DT;

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_DISTANCE_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _FTLDamping * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

#if ENABLE_CURVATURE
#define GS_LIVE_CONSTRAINTS 3
#elif ENABLE_DISTANCE || ENABLE_POSE_GLOBAL_ROTATION || ENABLE_POSE_LOCAL_BEND_TWIST
#define GS_LIVE_CONSTRAINTS 2
#else
#define GS_LIVE_CONSTRAINTS 1
#endif

struct PartialStrandPos
{
	float3 minus3;// ..
	float3 minus2;// ..
	float3 minus1;// head-1
	float3 minus0;// head
};

struct PartialStrandRot
{
	float4 minus1;// ..
	float4 minus0;// head
	float4 minus0_global;
};

void PartialStrand_SolveNext(
	inout PartialStrandPos p, inout PartialStrandRot q,
	const uint strandIndex, const uint strandParticleStride,
	const float3 rootPos,
	const uint i, const uint k, const float stiffness,
	const float w_minus2, const float w_minus1, const float w_minus0)
{
	p.minus3 = p.minus2;
	p.minus2 = p.minus1;
	p.minus1 = p.minus0;
	p.minus0 = _ParticlePosition[i].xyz;

	q.minus0_global = QMul(q.minus0_global, _InitialParticleFrameDelta[i]);

	if (ENABLE_POSE_GLOBAL_ROTATION)
	{
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), w_minus1, w_minus0, 0.0, p.minus1, p.minus0, q.minus0_global);
	}

	// GS_LIVE_CONSTRAINTS == 3
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                       `--------- solve ---------´
	//
	// GS_LIVE_CONSTRAINTS == 2
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                     `-- solve --´
	//
	// GS_LIVE_CONSTRAINTS == 1
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                                   `-- solve

	if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p.minus0);
	if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, p.minus0);
	if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, w_minus1, w_minus0, p.minus1, p.minus0);
	if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, rootPos, p.minus0);
	if (ENABLE_CURVATURE)			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, w_minus2, w_minus1, w_minus0, p.minus2, p.minus1, p.minus0);

	q.minus1 = q.minus0;
	q.minus0 = QMul(MakeQuaternionFromBend(p.minus2, p.minus1, p.minus0), q.minus1);

	if (ENABLE_POSE_LOCAL_BEND_TWIST)
	{
		float wq_minus1 = 0.5 * (w_minus2 + w_minus1);
		float wq_minus0 = 0.5 * (w_minus1 + w_minus0);

		ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, wq_minus1, wq_minus0, q.minus1, q.minus0);
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus1, w_minus0, wq_minus0, p.minus1, p.minus0, q.minus0);
	}

	// GS_LIVE_CONSTRAINTS == 3
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//    (anchor)          |`-------- modify ---------´
	//                      |
	//                     write
	//
	// GS_LIVE_CONSTRAINTS == 2
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                  (anchor)          |`- modify --´
	//                                    |
	//                                   write
	//
	// GS_LIVE_CONSTRAINTS == 1
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                (anchor)          |`-- modify
	//                                                  |
	//                                                 write

	if (ENABLE_DISTANCE_FTL)
	{
		if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus3, p.minus2, _ParticlePositionCorr[i - strandParticleStride * 3].xyz);
		if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus2, p.minus1, _ParticlePositionCorr[i - strandParticleStride * 2].xyz);
		if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus1, p.minus0, _ParticlePositionCorr[i - strandParticleStride * 1].xyz);
	}

	if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) _ParticlePosition[i - strandParticleStride * 2].xyz = p.minus2;
	if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) _ParticlePosition[i - strandParticleStride * 1].xyz = p.minus1;
	if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) _ParticlePosition[i - strandParticleStride * 0].xyz = p.minus0;
}

void PartialStrand_SolveTail(inout PartialStrandPos p, const uint strandIndex, const uint strandParticleStride, const uint strandParticleEnd)
{
	if (ENABLE_DISTANCE_FTL)
	{
		if (GS_LIVE_CONSTRAINTS >= 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus2, p.minus1, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz);
		if (GS_LIVE_CONSTRAINTS >= 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus1, p.minus0, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz);
	}

	if (GS_LIVE_CONSTRAINTS >= 3) _ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p.minus1;
	if (GS_LIVE_CONSTRAINTS >= 2) _ParticlePosition[strandParticleEnd - strandParticleStride * 1].xyz = p.minus0;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

#if DEBUG_STRAND_31_32
	if (strandIndex < 31 || strandIndex > 32)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePosition[i] = 1e+7;
		}
		return;
	}
#endif

	// update positions
	const float3 rootPos = _RootPosition[strandIndex].xyz;
	{
		// root
		_ParticlePosition[strandParticleBegin].xyz = rootPos;

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
#if SECOND_ORDER_PREDICTION
				float3 x0_minus1 = _ParticlePosition[i].xyz;
				float3 v0_minus1 = _ParticleVelocity[i].xyz;
				float3 xt = IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0);
#else
				float3 xt = IntegratePosition(x0, v0, a0);
#endif

				// solve global position constraints
				if (ENABLE_POSE_GLOBAL_POSITION)
				{
					float3 r0 = xt - rootPos;
					float3 r1 = QMul(_WorldRotation, _InitialParticleOffset[i].xyz * _StrandScale);

					xt = rootPos + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, k));
				}

				_ParticlePosition[i].xyz = xt;
			}
		}
	}

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// solve constraints by Gauss-Seidel iteration
	{
		float4 rootFrame = _RootFrame[strandIndex];
		float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

		for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
		{
			const float stiffness = GetIterationStiffness(__iteration);

			PartialStrandPos p;
			p.minus3 = rootPos - rootVec * 3.0;
			p.minus2 = rootPos - rootVec * 2.0;
			p.minus1 = rootPos - rootVec * 1.0;
			p.minus0 = rootPos;

			PartialStrandRot q;
			q.minus1 = MakeQuaternionIdentity();
			q.minus0 = rootFrame;
			q.minus0_global = rootFrame;

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride * 1;
				const uint k = 1;

				PartialStrand_SolveNext(p, q, strandIndex, strandParticleStride, rootPos, i, k, stiffness, 0.0, 0.0, 1.0);
			}

			// root+2
			{
				const uint i = strandParticleBegin + strandParticleStride * 2;
				const uint k = 2;

				PartialStrand_SolveNext(p, q, strandIndex, strandParticleStride, rootPos, i, k, stiffness, 0.0, 1.0, 1.0);
			}

			// root+3..
			for (uint i = strandParticleBegin + strandParticleStride * 3, k = 3; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				PartialStrand_SolveNext(p, q, strandIndex, strandParticleStride, rootPos, i, k, stiffness, 1.0, 1.0, 1.0);
			}

			// n-2, n-1
			PartialStrand_SolveTail(p, strandIndex, strandParticleStride, strandParticleEnd);
		}
	}

	// derive velocity from effective change in position
	{
		// root
		_ParticleVelocity[strandParticleBegin].xyz = (_ParticlePosition[strandParticleBegin].xyz - _ParticlePositionPrev[strandParticleBegin].xyz) / _DT;

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_DISTANCE_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _FTLDamping * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

// pad head so that index 0 == root-1
groupshared float4 gs_x[1 + THREAD_GROUP_SIZE];// xyz: position, w: weight
groupshared float3 gs_d[1 + THREAD_GROUP_SIZE];// xyz: ftl correction
groupshared float4 gs_q[1 + THREAD_GROUP_SIZE];// quat(xyz,w): material frame

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(groupIdx.x);

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;
	const uint j = threadIdx + 1;// for data in group shared memory (gs_*)

	// update positions
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	{
		// [threads: root]
		if (threadIdx == 0)
		{
			const float4 rootFrame = _RootFrame[strandIndex];
			const float3 rootPos = _RootPosition[strandIndex].xyz;
			const float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));
			{
				gs_x[0] = float4(rootPos - rootVec, 0.0);
				gs_x[1] = float4(rootPos, 0.0);
			}
		}
		// [threads: root+1..]
		else
		{
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
#if SECOND_ORDER_PREDICTION
				float3 x0_minus1 = _ParticlePosition[i].xyz;
				float3 v0_minus1 = _ParticleVelocity[i].xyz;
				gs_x[j] = float4(IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0), 1.0);
#else
				gs_x[j] = float4(IntegratePosition(x0, v0, a0), 1.0);
#endif
			}
		}
	}

	// clear corrections
	{
		// [threads: root]
		if (threadIdx == 0)
		{
			gs_d[0] = 0;
			gs_d[1] = 0;
		}
		// [threads: root+1..]
		else
		{
			gs_d[j] = 0;
		}
	}

	// build material frames
	{
		GroupMemoryBarrierWithGroupSync();

		// [threads: root]
		if (threadIdx == 0)
		{
			gs_q[0] = MakeQuaternionIdentity();
			gs_q[1] = _RootFrame[strandIndex];
		}
		// [threads: root+1..]
		else
		{
			gs_q[j] = MakeQuaternionFromBend(gs_x[j - 2].xyz, gs_x[j - 1].xyz, gs_x[j].xyz);
		}

		for (uint i = 0; i < THREAD_GROUP_SIZE; i++)
		{
			GroupMemoryBarrierWithGroupSync();

			if (i == threadIdx)
			{
				gs_q[j] = QMul(gs_q[j], gs_q[j - 1]);
				// e.g.
				// thread 0 writes: gs_q[0] = q_rot_0
				// thread 1 writes: gs_q[1] = QMul(q_rot_1, q_rot_0);
				// thread 2 writes: gs_q[2] = QMul(q_rot_2, QMul(q_rot_1, q_rot_0));
				// ...
			}
		}
	}

	// solve global position constraints
	if (ENABLE_POSE_GLOBAL_POSITION)
	{
		GroupMemoryBarrierWithGroupSync();

		// [threads: root+1..]
		if (threadIdx > 0)
		{
			float3 r0 = gs_x[j].xyz - gs_x[1].xyz;
			float3 r1 = QMul(_WorldRotation, _InitialParticleOffset[i].xyz * _StrandScale);

			gs_x[j].xyz = gs_x[1].xyz + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, threadIdx));
		}
	}

	// count tailing particles
	const uint num_tailing = (THREAD_GROUP_SIZE - 1) - threadIdx;

	// count acting constraints
	const uint num_acting_x = max(1,
		(ENABLE_BOUNDARY				? 1							: 0) +
		(ENABLE_BOUNDARY_FRICTION		? 1							: 0) +
		(ENABLE_DISTANCE				? min(2, 1 + num_tailing)	: 0) +
		(ENABLE_DISTANCE_LRA			? 1							: 0) +
		(ENABLE_DISTANCE_FTL			? 1							: 0) +
		(ENABLE_CURVATURE				? min(3, 1 + num_tailing)	: 0) +
		(ENABLE_POSE_LOCAL_BEND_TWIST	? min(2, 1 + num_tailing)	: 0) +
		(ENABLE_POSE_GLOBAL_ROTATION	? min(2, 1 + num_tailing)	: 0) +
		0);

	const uint num_acting_q = max(1,
		(ENABLE_POSE_LOCAL_BEND_TWIST	? min(3, 2 + num_tailing)	: 0) +
		(ENABLE_POSE_GLOBAL_ROTATION	? 1							: 0) +
		0);

	// solve constraints by Jacobi iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		GroupMemoryBarrierWithGroupSync();

		const float stiffness = GetIterationStiffness(__iteration);

		// [threads: root+1..]
		if (threadIdx > 0)
		{
			float3 corr_x = 0;
			float4 corr_q = 0;

			// solve boundary collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, gs_x[j], corr_x);
				else
					SolveCollisionConstraint(gs_x[j], corr_x);
			}

			// solve particle-particle distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 NOP;
				
				SolveDistanceConstraint(GetParticleInterval(strandIndex), stiffness, gs_x[j - 1], gs_x[j], NOP, corr_x);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), stiffness, gs_x[j], gs_x[j + 1], corr_x, NOP);
				}
			}

			// solve 'long range attachment' distance constraints
			if (ENABLE_DISTANCE_LRA)
			{
				SolveDistanceLRAConstraint(GetParticleInterval(strandIndex) * threadIdx, gs_x[1].xyz, gs_x[j].xyz, corr_x);
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 NOP;

				SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], NOP, NOP, corr_x);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], NOP, corr_x, NOP);

					// [threads: ..end-2]
					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], corr_x, NOP, NOP);
					}
				}
			}

			/* TODO
			// solve global rotation constraints
			if (ENABLE_POSE_GLOBAL_ROTATION)
			{
				float4 NOP;

				float4 q_j = QMul(gs_q[j - 1], _InitialParticleFrameDelta[i]);
				float4 q_j_corr = 0;

				SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, threadIdx), gs_x[j - 1].w, gs_x[j].w, 0.0, gs_x[j - 1].xyz, gs_x[j].xyz, q_j, NOP.xyz, corr_x, q_j_corr);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					float4 q_j_plus_1 = QMul(gs_q[j], _InitialParticleFrameDelta[i + strandParticleStride]);

					SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, threadIdx), gs_x[j].w, gs_x[j + 1].w, 0.0, gs_x[j].xyz, gs_x[j + 1].xyz, q_j_plus_1, corr_x, NOP.xyz, NOP);
				}

				corr_q += (q_j + q_j_corr - gs_q[j]) / _SOR;
			}
			*/

			// solve local shape constraints
			if (ENABLE_POSE_LOCAL_BEND_TWIST)
			{
				float4 NOP;

				const float wq_minus1 = 0.5 * (gs_x[j - 2].w + gs_x[j - 1].w);
				const float wq_minus0 = 0.5 * (gs_x[j - 1].w + gs_x[j - 0].w);

				SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, wq_minus1, wq_minus0, gs_q[j - 1], gs_q[j], NOP, corr_q);
				SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, gs_x[j - 1].w, gs_x[j].w, wq_minus0, gs_x[j - 1].xyz, gs_x[j].xyz, gs_q[j], NOP.xyz, corr_x, corr_q);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					float wq_plus1 = 0.5 * (gs_x[j].w + gs_x[j + 1].w);

					SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i + strandParticleStride], stiffness * _LocalShape, wq_minus0, wq_plus1, gs_q[j], gs_q[j + 1], corr_q, NOP);
					SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, gs_x[j].w, gs_x[j + 1].w, wq_plus1, gs_x[j].xyz, gs_x[j + 1].xyz, gs_q[j + 1], corr_x, NOP.xyz, NOP);
				}
			}

			// apply SOR and averaging
			corr_x *= _SOR / num_acting_x;
			corr_q *= _SOR / num_acting_q;

			// solve 'follow the leader' distance constraints
			if (ENABLE_DISTANCE_FTL)
			{
				float3 corr_x_ftl = 0;

				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, corr_x_ftl);

				corr_x_ftl *= 0.5 / num_acting_x;
				corr_x += corr_x_ftl;

				gs_d[j - 1] += corr_x_ftl;// correction to particle above current particle
			}

			// move to next iteration
			gs_x[j].xyz += corr_x;
			gs_q[j] = normalize(gs_q[j] + corr_q);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[j].xyz;

		if (ENABLE_DISTANCE_FTL)
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0 - _FTLDamping * gs_d[j]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0) / _DT;
	}
}


//========================================================================
//------------------ for reference, eventually deletion ------------------


//###  early local shape by rebuilding quats
/*
void SolveLocalShape()
{
	// solve local shape constraints
	if (ENABLE_POSE_LOCAL_ROTATION || ENABLE_POSE_LOCAL_BEND_TWIST)
	{
		float4 rootFrame = QMul(_WorldRotation, _InitialRootFrame[strandIndex]);
		float3 rootPos = _RootPosition[strandIndex].xyz;
		float3 rootDir = QMul(rootFrame, float3(0, 1, 0));

		// root
		float3 p0 = rootPos - rootDir * GetParticleInterval(strandIndex) * 3.0;
		float3 p1 = rootPos - rootDir * GetParticleInterval(strandIndex) * 2.0;
		float3 p2 = rootPos - rootDir * GetParticleInterval(strandIndex);
		float3 p3 = rootPos;

		float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

		// root+1
		{
			const uint i = strandParticleBegin + strandParticleStride;

			p0 = p1;// root-2
			p1 = p2;// root-1
			p2 = p3;// root
			p3 = _ParticlePosition[i].xyz;

			ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 0.0f, 1.0f, 0.0f, p2, p3, frame_p2p3);
		}

		// root+2..
		for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
		{
			p0 = p1;
			p1 = p2;
			p2 = p3;
			p3 = _ParticlePosition[i].xyz;

			if (ENABLE_POSE_LOCAL_ROTATION)
			{
				// calc current frame for segment [p1--p2] and target frame for [p2--p3]
				float4 frame_p1p2 = QMul(MakeQuaternionFromBend(p0, p1, p2), accuFrame);
				float4 frame_p2p3 = QMul(frame_p1p2, _InitialParticleFrameDelta[i]);

				// apply material frame constraint
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), 0.5 * stiffness * _LocalShape, 1.0f, 1.0f, 0.0f, p2, p3, frame_p2p3);

				// update settled frame
				accuFrame = QMul(MakeQuaternionFromBend(p0, p1, p2), accuFrame);
			}
			else if (ENABLE_POSE_LOCAL_BEND_TWIST)
			{
				// calc current frames for segments [p1--p2] and [p2--p3]
				float4 frame_p1p2 = QMul(MakeQuaternionFromBend(p0, p1, p2), accuFrame);
				float4 frame_p2p3 = QMul(MakeQuaternionFromBend(p1, p2, p3), frame_p1p2);

				// apply material frame constraints
				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, 1.0, 1.0, frame_p1p2, frame_p2p3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 1.0f, 1.0f, 0.0f, p2, p3, frame_p2p3);

				// update settled frame
				accuFrame = QMul(MakeQuaternionFromBend(p0, p1, p2), accuFrame);
			}

			_ParticlePosition[i - strandParticleStride].xyz = p2;
		}

		_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p3;
	}
}
*/


//###  early local shape in sliding window
/*
void PartialStrand_SolveNext(
	inout PartialStrand p,
	const uint strandIndex, const uint strandParticleStride,
	const float3 rootPos,
	const uint i, const uint k, const float stiffness,
	const float w_minus2, const float w_minus1, const float w_minus0)
{
	p.minus4 = p.minus3;
	p.minus3 = p.minus2;
	p.minus2 = p.minus1;
	p.minus1 = p.minus0;
	p.minus0 = _ParticlePosition[i].xyz;
	p.frameGlobal = QMul(p.frameGlobal, _InitialParticleFrameDelta[i]);

	if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p.minus0);
	if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, p.minus0);
	if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, w_minus1, w_minus0, p.minus1, p.minus0);
	if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, rootPos, p.minus0);
	if (ENABLE_CURVATURE)			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, w_minus2, w_minus1, w_minus0, p.minus2, p.minus1, p.minus0);

	if (ENABLE_POSE_GLOBAL_ROTATION)
	{
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), w_minus1, w_minus0, 1.0, p.minus1, p.minus0, p.frameGlobal);
	}

	if (ENABLE_POSE_LOCAL_ROTATION || ENABLE_POSE_LOCAL_BEND_TWIST)
	{
		// GS_LIVE_CONSTRAINTS == 3
		//
		// - -- frame ---------.
		// - --- m4 ---------- m3 ---------- m2 ---------- m1 ---------- m0
		//                                     `--------- solve ---------´
		//
		// GS_LIVE_CONSTRAINTS == 2
		//
		//         ,--------- frame ---------.
		// - --- m4 ---------- m3 ---------- m2 ---------- m1 ---------- m0
		//                                                   `-- solve --´
		//
		// GS_LIVE_CONSTRAINTS == 1
		//
		//                       ,--------- frame ---------.
		// - --- m4 ---------- m3 ---------- m2 ---------- m1 ---------- m0
		//                                                                 `- solve

		// calc frame for segment [m3 -- m2]
		float4 frame_minus3minus2;
		{
			if (GS_LIVE_CONSTRAINTS == 3) frame_minus3minus2 = QMul(MakeQuaternionFromBend(p.minus4, p.minus3, p.minus2), p.frame);
			if (GS_LIVE_CONSTRAINTS == 2) frame_minus3minus2 = p.frame;
			if (GS_LIVE_CONSTRAINTS == 1) frame_minus3minus2 = 0;// dummy case to satisfy variants
		}

		if (ENABLE_POSE_LOCAL_ROTATION)
		{
			float wq_minus1 = 0.5 * (w_minus2 + w_minus1);
			float wq_minus0 = 0.5 * (w_minus1 + w_minus0);

			// calc frame for segment [m2 -- m1] and target frame for [m1 -- m0]
			float4 frame_minus2minus1 = QMul(MakeQuaternionFromBend(p.minus3, p.minus2, p.minus1), frame_minus3minus2);
			float4 frame_minus1minus0 = QMul(frame_minus2minus1, _InitialParticleFrameDelta[i]);

			// apply material frame constraint
			ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), 0.5 * stiffness * _LocalShape, w_minus1, w_minus0, 0.0, p.minus1, p.minus0, frame_minus1minus0);
		}
		else if (ENABLE_POSE_LOCAL_BEND_TWIST)
		{
			float wq_minus1 = 0.5 * (w_minus2 + w_minus1);
			float wq_minus0 = 0.5 * (w_minus1 + w_minus0);

			// calc frames for segments [m2 -- m1] and [m1 -- m0]
			float4 frame_minus2minus1 = QMul(MakeQuaternionFromBend(p.minus3, p.minus2, p.minus1), frame_minus3minus2);
			float4 frame_minus1minus0 = QMul(MakeQuaternionFromBend(p.minus2, p.minus1, p.minus0), frame_minus2minus1);

			// apply material frame constraints
			ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, wq_minus1, wq_minus0, frame_minus2minus1, frame_minus1minus0);

		#if EX_BEND_TWIST_BIDIRECTIONAL
			if (w_minus0 != 0.0) ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus1, w_minus0, 0.0, p.minus1, p.minus0, frame_minus1minus0);
			if (w_minus1 != 0.0) ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus2, w_minus1, 0.0, p.minus2, p.minus1, frame_minus2minus1);
		#else
			ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus1, w_minus0, 0.0, p.minus1, p.minus0, frame_minus1minus0);
		#endif
		}
	}

	if (ENABLE_DISTANCE_FTL)
	{
		if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus3, p.minus2, _ParticlePositionCorr[i - strandParticleStride * 3].xyz);
		if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus2, p.minus1, _ParticlePositionCorr[i - strandParticleStride * 2].xyz);
		if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus1, p.minus0, _ParticlePositionCorr[i - strandParticleStride * 1].xyz);
	}

	if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) _ParticlePosition[i - strandParticleStride * 2].xyz = p.minus2;
	if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) _ParticlePosition[i - strandParticleStride * 1].xyz = p.minus1;
	if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) _ParticlePosition[i - strandParticleStride * 0].xyz = p.minus0;

	// GS_LIVE_CONSTRAINTS == 3
	//
	//        ,---------- frame ---------.
	// - --- p0 ---------- p1 ---------- p2 ---------- p3 ---------- p4
	//                                    |`-------- modify ---------´
	//                                    |
	//                                   final
	//
	// GS_LIVE_CONSTRAINTS == 2
	//
	//                      ,---------- frame ---------.
	// - --- p0 ---------- p1 ---------- p2 ---------- p3 ---------- p4
	//                                                  |`- modify --´
	//                                                  |
	//                                                 final
	//
	// GS_LIVE_CONSTRAINTS == 1
	//
	//                                    ,---------- frame ---------.
	// - --- p0 ---------- p1 ---------- p2 ---------- p3 ---------- p4
	//                                                                |`- modify
	//                                                                |
	//                                                               final

	if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) p.frame = QMul(MakeQuaternionFromBend(p.minus4, p.minus3, p.minus2), p.frame);
	if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) p.frame = QMul(MakeQuaternionFromBend(p.minus3, p.minus2, p.minus1), p.frame);
	if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) p.frame = QMul(MakeQuaternionFromBend(p.minus2, p.minus1, p.minus0), p.frame);
}
*/


//###  early gauss seidel
/*
// solve constraints by Gauss-Seidel iteration
for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
{
	const float stiffness = GetIterationStiffness(__iteration);

	float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
	float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
	float3 r0 = p0 - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

	//      p1 <-- solve
	//     /
	//--- p0 <-- fixed (root)
	//    |
	//    r0 <-- fixed (root-1)
	if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p1);
	if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[strandParticleBegin + strandParticleStride].xyz, p1);
	if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.0, 1.0, p0, p1);
	if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex), p0, p1);
	if (ENABLE_CURVATURE)			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);
	if (ENABLE_DISTANCE_FTL)
	{
		if (GS_LIVE_CONSTRAINTS == 1) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[strandParticleBegin].xyz);
	}

#if DEBUG_STRAND_31_32 == 2
	{
		_ParticlePosition[strandParticleBegin + strandParticleStride].xyz = p1;
		_ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz = 1e+7;
		continue;
	}
#endif

	//      p2 <-- solve
	//      |
	//      p1 <-- solve
	//     /
	//--- p0 <-- fixed (root)
	//    |
	//    r0
	if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p2);
	if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[strandParticleBegin + strandParticleStride * 2].xyz, p2);
	if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p1, p2);
	if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * 2, _ParticlePosition[strandParticleBegin].xyz, p2);
	if (ENABLE_CURVATURE)			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);
	if (ENABLE_DISTANCE_FTL)
	{
		if (GS_LIVE_CONSTRAINTS == 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[strandParticleBegin].xyz);
		if (GS_LIVE_CONSTRAINTS == 1) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, _ParticlePositionCorr[strandParticleBegin + strandParticleStride].xyz);
	}

	for (uint i = strandParticleBegin + strandParticleStride * 3, k = 3; i != strandParticleEnd; i += strandParticleStride, k++)
	{
		r0 = p0;
		p0 = p1;
		p1 = p2;
		p2 = _ParticlePosition[i].xyz;

		//      p2 <-- solve
		//      |
		//      p1 <-- solve
		//     /
		//    p0 <-- solve
		//    |
		//--- r0
		if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p2);
		if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, p2);
		if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p1, p2);
		if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, _ParticlePosition[strandParticleBegin].xyz, p2);
		if (ENABLE_CURVATURE)			ApplyTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);
		if (ENABLE_DISTANCE_FTL)
		{
			if (GS_LIVE_CONSTRAINTS == 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), r0, p0, _ParticlePositionCorr[i - strandParticleStride * 3].xyz);
			if (GS_LIVE_CONSTRAINTS == 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[i - strandParticleStride * 2].xyz);
			if (GS_LIVE_CONSTRAINTS == 1) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, _ParticlePositionCorr[i - strandParticleStride * 1].xyz);
		}

		_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
	}

	//      p2 <-- solve (ftl)
	//     /
	//    p1 <-- solve (ftl)
	//    |
	//    p0
	if (ENABLE_DISTANCE_FTL)
	{
		if (GS_LIVE_CONSTRAINTS >= 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz);
		if (GS_LIVE_CONSTRAINTS >= 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz);
	}

	_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
	_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
}
*/


//###  early jacobi
/*
groupshared float3 gs_x[THREAD_GROUP_SIZE];
groupshared float3 gs_d[THREAD_GROUP_SIZE];

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(groupIdx.x);

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		gs_d[threadIdx] = 0;
	}

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
	const float3 a0 = float3(0.0, _Gravity, 0.0);
	{
		if (threadIdx == 0)
			gs_x[threadIdx] = _RootPosition[strandIndex].xyz;
		else
			gs_x[threadIdx] = IntegratePosition(x0, v0, a0);
	}

	// solve constraints by Jacobi iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			uint n = 0;
			float3 d = 0;

			// solve collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, 1.0, gs_x[threadIdx], d);
				else
					SolveCollisionConstraint(1.0, gs_x[threadIdx], d);

				n++;
			}

			// solve distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 nop = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx == 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.0, 1.0, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
				}
				else
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
					}
				}

				d += sum * stiffness;
				n += count;
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 nop1 = 0;
				float3 nop2 = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx <= 1)
				{
					const uint j = threadIdx;
					const float3 gs_x_rooted = gs_x[0] - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

					SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 0.0, 0.0, 1.0, gs_x_rooted, gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;
					SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 0.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
				}
				else
				{
					const uint j = threadIdx;

					SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, threadIdx != 2 ? 1.0 : 0.0, 1.0, 1.0, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 1.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					}

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
					}
				}

				d += sum * stiffness;
				n += count;
			}

			// solve hard distance constraints along strand (FTL)
			if (ENABLE_DISTANCE_FTL)
			{
				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_pre_ftl = d;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[threadIdx - 1], gs_x[threadIdx], d); n++;

				float inv_n = _SOR / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
				gs_d[threadIdx - 1] += (d - d_pre_ftl) * inv_n;
			}
			else
			{
				float inv_n = _SOR / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[threadIdx];

		if (ENABLE_DISTANCE_FTL)
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0 - _FTLDamping * gs_d[threadIdx]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0) / _DT;
	}
}
//*/
