#pragma kernel KInitParticles							THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128

//----------
// features

#pragma multi_compile_local __ LAYOUT_INTERLEAVED
// 0 == particles grouped by strand, i.e. root, root+1, root, root+1
// 1 == particles grouped by index, i.e. root, root, root+1, root+1

#pragma multi_compile_local __ ENABLE_DISTANCE
#pragma multi_compile_local __ ENABLE_DISTANCE_LRA
#pragma multi_compile_local __ ENABLE_DISTANCE_FTL
#pragma multi_compile_local __ ENABLE_BOUNDARY ENABLE_BOUNDARY_FRICTION
#pragma multi_compile_local __ ENABLE_CURVATURE_EQ ENABLE_CURVATURE_GEQ ENABLE_CURVATURE_LEQ
#pragma multi_compile_local __ ENABLE_SHAPE_GLOBAL

#define ENABLE_VOLUME_PRESSURE 1
#define ENABLE_VOLUME_FRICTION 1

#ifndef ENABLE_DISTANCE
#define ENABLE_DISTANCE 0
#endif
#ifndef ENABLE_DISTANCE_LRA
#define ENABLE_DISTANCE_LRA 0
#endif
#ifndef ENABLE_DISTANCE_FTL
#define ENABLE_DISTANCE_FTL 0
#endif
#ifndef ENABLE_BOUNDARY
#define ENABLE_BOUNDARY 0
#endif
#ifndef ENABLE_BOUNDARY_FRICTION
#define ENABLE_BOUNDARY_FRICTION 0
#endif
#ifndef ENABLE_CURVATURE_EQ
#define ENABLE_CURVATURE_EQ 0
#endif
#ifndef ENABLE_CURVATURE_GEQ
#define ENABLE_CURVATURE_GEQ 0
#endif
#ifndef ENABLE_CURVATURE_LEQ
#define ENABLE_CURVATURE_LEQ 0
#endif
#ifndef ENABLE_SHAPE_GLOBAL
#define ENABLE_SHAPE_GLOBAL 0
#endif

//---------
// include

#define HAIRSIM_WRITEABLE_SOLVERDATA 1

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverConstraints.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

//--------
// macros

#define ENABLE_CURVATURE (ENABLE_CURVATURE_EQ || ENABLE_CURVATURE_GEQ || ENABLE_CURVATURE_LEQ)

#if ENABLE_CURVATURE_GEQ
  #define ApplySelectTriangleBendingConstraint ApplyTriangleBendingMinConstraint
  #define SolveSelectTriangleBendingConstraint SolveTriangleBendingMinConstraint
#elif ENABLE_CURVATURE_LEQ
  #define ApplySelectTriangleBendingConstraint ApplyTriangleBendingMaxConstraint
  #define SolveSelectTriangleBendingConstraint SolveTriangleBendingMaxConstraint
#else
  #define ApplySelectTriangleBendingConstraint ApplyTriangleBendingConstraint
  #define SolveSelectTriangleBendingConstraint SolveTriangleBendingConstraint
#endif

#if ENABLE_CURVATURE
  #define GS_LIVE_CONSTRAINTS 3
#elif ENABLE_DISTANCE
  #define GS_LIVE_CONSTRAINTS 2
#else
  #define GS_LIVE_CONSTRAINTS 1
#endif

#if ENABLE_DISTANCE_LRA
  #define GS_LIVE_ROOT 1
#else
  #define GS_LIVE_ROOT 0
#endif

#if LAYOUT_INTERLEAVED
  #define DECLARE_STRAND(x)							\
	if (x >= _StrandCount) return;					\
	const uint strandIndex = x;						\
	const uint strandParticleBegin = strandIndex;	\
	const uint strandParticleStride = _StrandCount;	\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#else
  #define DECLARE_STRAND(x)													\
	if (x >= _StrandCount) return;											\
	const uint strandIndex = x;												\
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;	\
	const uint strandParticleStride = 1;									\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#endif

//#define STRAND_INDEX strandIndex
//#define STRAND_PARTICLE_BEGIN strandParticleBegin
//#define STRAND_PARTICLE_STRIDE strandParticleStride
//#define STRAND_PARTICLE_END strandParticleEnd

//---------
// utility

float3 ParticleVolumeImpulse(uint i, float3 velocity)
{
	float3 volumeUVW = VolumeWorldToUVW(_ParticlePositionPrev[i].xyz);

#if ENABLE_VOLUME_PRESSURE
	float3 volumePressureGradient = VolumeSampleVector(_VolumePressureGrad, volumeUVW);
	float3 volumePressureImpulse = -volumePressureGradient;// * (_DT / volumeDensity);
#else
	float3 volumePressureImpulse = 0.0;
#endif

#if ENABLE_VOLUME_FRICTION
  #if SPLAT_TRILINEAR
	float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_trilinear_clamp);
  #else
	float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_point_clamp);
  #endif
	float3 volumeVelocityImpulse = (volumeVelocity - velocity);
#else
	float3 volumeVelocityImpulse = 0.0;
#endif

	return (
		volumePressureImpulse * _CellPressure +
		volumeVelocityImpulse * _CellVelocity
	);
}

float GetDecay(float smoothing)
{
	return pow(max(1e-4, smoothing), _DT);
}

float GetDampingDecay()
{
	return GetDecay(1.0 - _Damping);
}

float GetIterationStiffness(uint iteration)
{
	return 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / _Iterations);// (1 + iteration));
}

float GetParticleInterval(uint strandIndex)
{
	return (_StrandMaxParticleInterval * _StrandScale) * _RootScale[strandIndex];
}

float GetBendingRadius(uint strandIndex)
{
	return _BendingCurvature * GetParticleInterval(strandIndex);
}

float GetShapeStiffness(uint strandIndex, uint linearParticleIndex)
{
	float t = (_RootScale[strandIndex] * linearParticleIndex) / (float)(_StrandParticleCount - 1);
	return _ShapeStiffness * pow(abs(1.0 - t), _ShapeFalloff);
}

float3 IntegratePosition(float3 x0, float3 v0, float3 a0)
{
	return x0 + _DT * (v0 * GetDampingDecay() + _DT * a0);
}

//--------------
// kernels init

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitParticles(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);
	
	float3 rootPos = _RootPosition[strandIndex].xyz;
	float3 rootPosPrev = _ParticlePosition[strandParticleBegin].xyz;
	
	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 v = _ParticlePosition[i].xyz - rootPosPrev;
		float3 p = rootPos + mul(_LocalToWorld, float4(v, 0.0)).xyz;
		
		_ParticlePosition[i].xyz = p;
		_ParticlePositionPrev[i].xyz = p;
		_ParticlePositionCorr[i].xyz = 0.0;
		_ParticlePositionPose[i].xyz = v;
		_ParticleVelocity[i] = float4(0.0, 0.0, 0.0, _StrandMaxParticleWeight * _RootScale[strandIndex]);
		_ParticleVelocityPrev[i] = float4(0.0, 0.0, 0.0, _StrandMaxParticleWeight * _RootScale[strandIndex]);
	}
}

//---------------
// kernels solve

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	// update positions
	{
		_ParticlePosition[strandParticleBegin].xyz = _RootPosition[strandIndex].xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
			}
		}
	}

	// apply global shape
	if (ENABLE_SHAPE_GLOBAL)
	{
		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			float3 v = _ParticlePosition[i].xyz - p0;
			float3 w = mul(_LocalToWorld, float4(_ParticlePositionPose[i].xyz, 0.0)).xyz;

			_ParticlePosition[i].xyz = p0 + lerp(v, w, 1.0 - GetDecay(1.0 - GetShapeStiffness(strandIndex, k)));
		}
	}

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i].xyz = 0;
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		// solve collision constraints
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, _ParticlePosition[i].xyz);
				else
					ApplyCollisionConstraint(_ParticlePosition[i].xyz);
			}
		}

		// solve distance constraints
		if (ENABLE_DISTANCE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.0, 1.0, p0, p1);

			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve long range distance constraints
		if (ENABLE_DISTANCE_LRA)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				float3 p1 = _ParticlePosition[i].xyz;

				ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, p0, p1);

				_ParticlePosition[i].xyz = p1;
			}
		}

		// solve triangle bending constraints
		if (ENABLE_CURVATURE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

			//      p1 <-- solve
			//     /
			//--- p0 <-- fixed (root)
			//    |
			//    r0 <-- fixed (root -1)
			ApplySelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 <-- fixed (root)
			//    |
			//    ##
			ApplySelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ##
				ApplySelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}
		
		// solve hard distance constraints along strand (FTL)
		if (ENABLE_DISTANCE_FTL)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionCorr[i - strandParticleStride].xyz += d1;

				p0 = p1;
			}
		}
	}

	// derive velocity from effective change in position
	{
		_ParticleVelocity[strandParticleBegin].xyz = (_ParticlePosition[strandParticleBegin].xyz - _ParticlePositionPrev[strandParticleBegin].xyz) / _DT;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_DISTANCE_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _DampingFTL * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

#if DEBUG_STRAND_31_32
	if (strandIndex < 31 || strandIndex > 32)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePosition[i] = 1e+7;
		}
		return;
	}
#endif

#if 0// PAUSE SOLVER
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePosition[i] = _ParticlePositionPrev[i];
		}
		return;
	}
#endif

	// update position
	{
		_ParticlePosition[strandParticleBegin].xyz = _RootPosition[strandIndex].xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
			}
		}
	}

	// apply global shape
	if (ENABLE_SHAPE_GLOBAL)
	{
		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			float3 v = _ParticlePosition[i].xyz - p0;
			float3 w = mul(_LocalToWorld, float4(_ParticlePositionPose[i].xyz, 0.0)).xyz;

			_ParticlePosition[i].xyz = p0 + lerp(v, w, 1.0 - GetDecay(1.0 - GetShapeStiffness(strandIndex, k)));
		}
	}

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
		float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
		float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
		float3 r0 = p0 - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

		//      p1 <-- solve
		//     /
		//--- p0 <-- fixed (root)
		//    |
		//    r0 <-- fixed (root -1)
		if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p1);
		if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[strandParticleBegin + strandParticleStride].xyz, p1);
		if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.0, 1.0, p0, p1);
		if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex), p0, p1);
		if (ENABLE_CURVATURE)			ApplySelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);
		if (ENABLE_DISTANCE_FTL)
		{
			if (GS_LIVE_CONSTRAINTS == 1) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[strandParticleBegin].xyz);
		}
		
#if DEBUG_STRAND_31_32 == 2
		{
			_ParticlePosition[strandParticleBegin + strandParticleStride].xyz = p1;
			_ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz = 1e+7;
			continue;
		}
#endif

		//      p2 <-- solve
		//      |
		//      p1 <-- solve
		//     /
		//--- p0 <-- fixed (root)
		//    |
		//    r0
		if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p2);
		if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[strandParticleBegin + strandParticleStride * 2].xyz, p2);
		if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p1, p2);
		if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * 2, _ParticlePosition[strandParticleBegin].xyz, p2);
		if (ENABLE_CURVATURE)			ApplySelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);
		if (ENABLE_DISTANCE_FTL)
		{
			if (GS_LIVE_CONSTRAINTS == 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[strandParticleBegin].xyz);
			if (GS_LIVE_CONSTRAINTS == 1) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, _ParticlePositionCorr[strandParticleBegin + strandParticleStride].xyz);
		}
		
		for (uint i = strandParticleBegin + strandParticleStride * 3, k = 3; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			r0 = p0;
			p0 = p1;
			p1 = p2;
			p2 = _ParticlePosition[i].xyz;

			//      p2 <-- solve
			//      |
			//      p1 <-- solve
			//     /
			//    p0 <-- solve
			//    |
			//--- r0
			if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p2);
			if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, p2);
			if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p1, p2);
			if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, _ParticlePosition[strandParticleBegin].xyz, p2);
			if (ENABLE_CURVATURE)			ApplySelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);
			if (ENABLE_DISTANCE_FTL)
			{
				if (GS_LIVE_CONSTRAINTS == 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), r0, p0, _ParticlePositionCorr[i - strandParticleStride * 3].xyz);
				if (GS_LIVE_CONSTRAINTS == 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[i - strandParticleStride * 2].xyz);
				if (GS_LIVE_CONSTRAINTS == 1) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, _ParticlePositionCorr[i - strandParticleStride * 1].xyz);
			}

			_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
		}

		//      p2 <-- solve (ftl)
		//     /
		//    p1 <-- solve (ftl)
		//    |
		//    p0
		if (ENABLE_DISTANCE_FTL)
		{
			if (GS_LIVE_CONSTRAINTS >= 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz);
			if (GS_LIVE_CONSTRAINTS >= 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz);
		}

		_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
		_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
	}

	// derive velocity from effective change in position
	{
		_ParticleVelocity[strandParticleBegin].xyz = (_ParticlePosition[strandParticleBegin].xyz - _ParticlePositionPrev[strandParticleBegin].xyz) / _DT;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_DISTANCE_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _DampingFTL * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

#define SPLIT_FTL 0

#define NEW_JACOBI 1
#if NEW_JACOBI
groupshared float4 gs_x[THREAD_GROUP_SIZE + 1];// pad head so that 0 == root -1
groupshared float3 gs_d[THREAD_GROUP_SIZE + 1];// pad head so that 0 == root -1
#else
groupshared float3 gs_x[THREAD_GROUP_SIZE];
groupshared float3 gs_d[THREAD_GROUP_SIZE];
#endif

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(groupIdx.x);

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;
#if NEW_JACOBI

	const uint j = threadIdx + 1;
	
	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	{
		if (threadIdx == 0)
		{
			const float3 rootPosition = _RootPosition[strandIndex].xyz;
			const float3 rootDirection = _RootDirection[strandIndex].xyz;
			{
				gs_x[0] = float4(rootPosition - rootDirection * GetParticleInterval(strandIndex), 0.0);
				gs_x[1] = float4(rootPosition, 0.0);
			}
		}
		else
		{
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				gs_x[j] = float4(IntegratePosition(x0, v0, a0), 1.0);
				gs_d[j] = 0;
			}
		}
	}

	// apply global shape
	if (ENABLE_SHAPE_GLOBAL)
	{
		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			float3 v = gs_x[j].xyz - gs_x[1].xyz;
			float3 w = mul(_LocalToWorld, float4(_ParticlePositionPose[i].xyz, 0.0)).xyz;

			gs_x[j].xyz = gs_x[1].xyz + lerp(v, w, 1.0 - GetDecay(1.0 - GetShapeStiffness(strandIndex, threadIdx)));
		}
	}

	// count effective constraints
	const uint num_particles_tailing = (THREAD_GROUP_SIZE - 1) - threadIdx;
	const uint num_constraints = max(1,
		(ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION) +
		ENABLE_DISTANCE * min(2, 1 + num_particles_tailing) +
		ENABLE_DISTANCE_LRA +
		ENABLE_CURVATURE * min(3, 1 + num_particles_tailing) +
	#if SPLIT_FTL
		0
	#else
		ENABLE_DISTANCE_FTL
	#endif
		);

	const float n_inv = 1.0 / num_constraints;

	// solve constraints by Jacobi iteration
	float3 d_ftl = 0;

	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			float3 d = 0;

			// solve collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, gs_x[j], d);
				else
					SolveCollisionConstraint(gs_x[j], d);
			}

			// solve distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 nop = 0;

				SolveDistanceConstraint(GetParticleInterval(strandIndex), stiffness, gs_x[j - 1], gs_x[j], nop, d);

				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), stiffness, gs_x[j], gs_x[j + 1], d, nop);
				}
			}

			// solve long range distance constraints
			if (ENABLE_DISTANCE_LRA)
			{
				SolveDistanceLRAConstraint(GetParticleInterval(strandIndex) * threadIdx, gs_x[1].xyz, gs_x[j].xyz, d);
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 nop = 0;

				SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop, nop, d);

				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop, d, nop);

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], d, nop, nop);
					}
				}
			}

			// apply SOR
			d *= _SOR;

			// solve hard distance constraints along strand (FTL)
			if (ENABLE_DISTANCE_FTL)
			{
#if SPLIT_FTL

				float3 d_tmp = 0;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, d_tmp);
				d_ftl += d_tmp;

				// move to next iteration
				gs_x[j].xyz += (d * n_inv) + d_tmp;

#else

				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_tmp = 0;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, d_tmp);
				d_ftl += d_tmp * n_inv;

				// move to next iteration
				gs_x[j].xyz += (d + d_tmp) * n_inv;

#endif
			}
			else
			{
				// move to next iteration
				gs_x[j].xyz += d * n_inv;
			}
		}
	}

	if (ENABLE_DISTANCE_FTL)
	{
		gs_d[j - 1] = d_ftl * min(1, threadIdx);//TODO fix this
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[j].xyz;

		if (ENABLE_DISTANCE_FTL)
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0 - _DampingFTL * gs_d[j]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0) / _DT;
	}

#else
	//---------------------------------- ORIGINAL -----------------------------

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		gs_d[threadIdx] = 0;
	}

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
	const float3 a0 = float3(0.0, _Gravity, 0.0);
	{
		if (threadIdx == 0)
			gs_x[threadIdx] = _RootPosition[strandIndex].xyz;
		else
			gs_x[threadIdx] = IntegratePosition(x0, v0, a0);
	}

	// solve constraints by Jacobi iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			uint n = 0;
			float3 d = 0;

			// solve collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, 1.0, gs_x[threadIdx], d);
				else
					SolveCollisionConstraint(1.0, gs_x[threadIdx], d);

				n++;
			}

			// solve distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 nop = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx == 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.0, 1.0, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
				}
				else
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					
					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
					}
				}

				d += sum * stiffness;
				n += count;
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 nop1 = 0;
				float3 nop2 = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx <= 1)
				{
					const uint j = threadIdx;
					const float3 gs_x_rooted = gs_x[0] - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

					SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 0.0, 0.0, 1.0, gs_x_rooted, gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;
					SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 0.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
				}
				else
				{
					const uint j = threadIdx;

					SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, threadIdx != 2 ? 1.0 : 0.0, 1.0, 1.0, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 1.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					}

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveSelectTriangleBendingConstraint(GetBendingRadius(strandIndex), 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
					}
				}

				d += sum * stiffness;
				n += count;
			}

			// solve hard distance constraints along strand (FTL)
			if (ENABLE_DISTANCE_FTL)
			{
				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_pre_ftl = d;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[threadIdx - 1], gs_x[threadIdx], d); n++;

				float inv_n = _SOR / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
				gs_d[threadIdx - 1] += (d - d_pre_ftl) * inv_n;
			}
			else
			{
				float inv_n = _SOR / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[threadIdx];

		if (ENABLE_DISTANCE_FTL)
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0 - _DampingFTL * gs_d[threadIdx]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0) / _DT;
	}
#endif
}
