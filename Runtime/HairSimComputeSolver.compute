#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128

#pragma multi_compile_local __ LAYOUT_INTERLEAVED
// 0 == particles grouped by strand, i.e. root, root+1, root, root+1
// 1 == particles grouped by index, i.e. root, root, root+1, root+1

#pragma multi_compile_local __ ENABLE_DISTANCE
#pragma multi_compile_local __ ENABLE_DISTANCE_LRA
#pragma multi_compile_local __ ENABLE_DISTANCE_FTL
#pragma multi_compile_local __ ENABLE_BOUNDARY ENABLE_BOUNDARY_FRICTION
#pragma multi_compile_local __ ENABLE_CURVATURE_EQ ENABLE_CURVATURE_GEQ ENABLE_CURVATURE_LEQ

#ifndef ENABLE_DISTANCE
#define ENABLE_DISTANCE 0
#endif
#ifndef ENABLE_DISTANCE_LRA
#define ENABLE_DISTANCE_LRA 0
#endif
#ifndef ENABLE_DISTANCE_FTL
#define ENABLE_DISTANCE_FTL 0
#endif
#ifndef ENABLE_BOUNDARY
#define ENABLE_BOUNDARY 0
#endif
#ifndef ENABLE_BOUNDARY_FRICTION
#define ENABLE_BOUNDARY_FRICTION 0
#endif
#ifndef ENABLE_CURVATURE_EQ
#define ENABLE_CURVATURE_EQ 0
#endif
#ifndef ENABLE_CURVATURE_GEQ
#define ENABLE_CURVATURE_GEQ 0
#endif
#ifndef ENABLE_CURVATURE_LEQ
#define ENABLE_CURVATURE_LEQ 0
#endif

#define ENABLE_CURVATURE (ENABLE_CURVATURE_EQ || ENABLE_CURVATURE_GEQ || ENABLE_CURVATURE_LEQ)

#if ENABLE_CURVATURE_GEQ
	#define ApplySelectTriangleBendingConstraint ApplyTriangleBendingMinConstraint
	#define SolveSelectTriangleBendingConstraint SolveTriangleBendingMinConstraint
#elif ENABLE_CURVATURE_LEQ
	#define ApplySelectTriangleBendingConstraint ApplyTriangleBendingMaxConstraint
	#define SolveSelectTriangleBendingConstraint SolveTriangleBendingMaxConstraint
#else
	#define ApplySelectTriangleBendingConstraint ApplyTriangleBendingConstraint
	#define SolveSelectTriangleBendingConstraint SolveTriangleBendingConstraint
#endif

#define ENABLE_VOLUME_PRESSURE 1
#define ENABLE_VOLUME_FRICTION 1

#define HAIRSIM_WRITEABLE_SOLVERDATA 1

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverConstraints.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

//---------
// utility

float3 ParticleVolumeImpulse(uint i, float3 velocity)
{
	float3 volumeUVW = VolumeWorldToUVW(_ParticlePositionPrev[i].xyz);

#if ENABLE_VOLUME_PRESSURE
	float3 volumePressureGradient = VolumeSampleVector(_VolumePressureGrad, volumeUVW);
	float3 volumePressureImpulse = -volumePressureGradient;// * (_DT / volumeDensity);
#else
	float3 volumePressureImpulse = 0.0;
#endif

#if ENABLE_VOLUME_FRICTION
  #if SPLAT_TRILINEAR
	float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_trilinear_clamp);
  #else
	float3 volumeVelocity = VolumeSampleVector(_VolumeVelocity, volumeUVW, _Volume_point_clamp);
  #endif
	float3 volumeFrictionImpulse = (volumeVelocity - velocity);
#else
	float3 volumeFrictionImpulse = 0.0;
#endif

	return (
		volumePressureImpulse * _VolumePressureScale +
		volumeFrictionImpulse * _VolumeFrictionScale
	);
}

float GetDampingDecay()
{
	return pow(max(1e-4, 1.0 - _Damping), _DT);
}

float GetIterationStiffness(uint iteration)
{
	return 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / (iteration + 1));
}

float GetParticleInterval(uint strandIndex)
{
	return _Length[strandIndex] / (_StrandParticleCount - 1);
}

float3 IntegratePosition(float3 x0, float3 v0, float3 a0)
{
	return x0 + _DT * (v0 * GetDampingDecay() + _DT * a0);
}

//---------
// kernels

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i].xyz = 0;
		}
	}

	// update positions
	{
		_ParticlePosition[strandParticleBegin].xyz = _RootPosition[strandIndex].xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
			}
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		// solve collision constraints
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, _ParticlePosition[i].xyz);
				else
					ApplyCollisionConstraint(_ParticlePosition[i].xyz);
			}
		}

		// solve distance constraints
		if (ENABLE_DISTANCE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.0, 1.0, p0, p1);

			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve long range distance constraints
		if (ENABLE_DISTANCE_LRA)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				float3 p1 = _ParticlePosition[i].xyz;

				ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, p0, p1);

				_ParticlePosition[i].xyz = p1;
			}
		}

		// solve triangle bending constraints
		if (ENABLE_CURVATURE)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

			//      p1 <-- solve
			//     /
			//--- p0 (fixed)
			//    |
			//    r0 (below)
			ApplySelectTriangleBendingConstraint(_BendingCurvature, stiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 (fixed)
			//    |
			//    ## (below)
			ApplySelectTriangleBendingConstraint(_BendingCurvature, stiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ## (fixed)
				//    |
				//    ## (below)
				ApplySelectTriangleBendingConstraint(_BendingCurvature, stiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}

		// solve distance constraints along strand (FTL)
		if (ENABLE_DISTANCE_FTL)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionCorr[i - strandParticleStride].xyz += d1;

				p0 = p1;
			}
		}
	}

	// derive velocity from effective change in position
	{
		//TODO also add this line to Jacobi solver
		_ParticleVelocity[strandParticleBegin].xyz = (_ParticlePosition[strandParticleBegin].xyz - _ParticlePositionPrev[strandParticleBegin].xyz) / _DT;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_DISTANCE_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _DampingFTL * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = worldIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

#if STRAND_31_32_DEBUG
	if (strandIndex < 31 || strandIndex > 32)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePosition[i] = 1e+7;
		}
		return;
	}
#endif

#if 0// PAUSE SOLVER
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePosition[i] = _ParticlePositionPrev[i];
		}
		return;
	}
#endif

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// update position
	{
		_ParticlePosition[strandParticleBegin].xyz = _RootPosition[strandIndex].xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
			}
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
		float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
		float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
		float3 r0 = p0 - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

		//      p1 <-- solve
		//     /
		//--- p0 (fixed)
		//    |
		//    r0 (below)
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[strandParticleBegin + strandParticleStride].xyz, p1);
			else/* frictionless */			ApplyCollisionConstraint(p1);
		}
		if (ENABLE_DISTANCE)		ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.0, 1.0, p0, p1);
		if (ENABLE_DISTANCE_LRA)	ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex), p0, p1);
		if (ENABLE_CURVATURE)		ApplySelectTriangleBendingConstraint(_BendingCurvature, stiffness, 0.0, 0.0, 1.0, r0, p0, p1);
		
#if STRAND_31_32_DEBUG == 2
		{
			_ParticlePosition[strandParticleBegin + strandParticleStride].xyz = p1;
			_ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz = 1e+7;
			continue;
		}
#endif

		//      p2 <-- solve
		//     /
		//    p1 <-- solve
		//    |
		//--- p0 (fixed)
		//    |
		//    r0 (below)
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[strandParticleBegin + strandParticleStride * 2].xyz, p2);
			else/* frictionless */			ApplyCollisionConstraint(p2);
		}
		if (ENABLE_DISTANCE)		ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p1, p2);
		if (ENABLE_DISTANCE_LRA)	ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * 2, _ParticlePosition[strandParticleBegin].xyz, p2);
		if (ENABLE_CURVATURE)		ApplySelectTriangleBendingConstraint(_BendingCurvature, stiffness, 0.0, 1.0, 1.0, p0, p1, p2);

		for (uint i = strandParticleBegin + strandParticleStride * 3, k = 0; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			r0 = p0;
			p0 = p1;
			p1 = p2;
			p2 = _ParticlePosition[i].xyz;

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//    p0 <-- solve
			//    |
			//--- r0 (fixed)
			//    |
			//    ## (below)
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, p2);
				else/* frictionless */			ApplyCollisionConstraint(p2);
			}
			if (ENABLE_DISTANCE)		ApplyDistanceConstraint(GetParticleInterval(strandIndex), stiffness, 0.5, 0.5, p1, p2);
			if (ENABLE_DISTANCE_LRA)	ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, _ParticlePosition[strandParticleBegin].xyz, p2);
			if (ENABLE_CURVATURE)		ApplySelectTriangleBendingConstraint(_BendingCurvature, stiffness, 1.0, 1.0, 1.0, p0, p1, p2);

			if (ENABLE_DISTANCE_FTL)
			{
				float3 d0 = 0;
				ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), r0, p0, d0);
				_ParticlePositionCorr[i - strandParticleStride * 3].xyz += d0;
			}

			_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
		}

		//TODO figure out why this breaks when triangle bending constraint is disabled
		if (ENABLE_DISTANCE_FTL)
		{
			float3 d1 = 0;
			ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, d1);
			_ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz += d1;

			float3 d2 = 0;
			ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p1, p2, d2);
			_ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz += d2;
		}

		_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
		_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
	}

	// derive velocity from effective change in position
	{
		_ParticleVelocity[strandParticleBegin].xyz = (_ParticlePosition[strandParticleBegin].xyz - _ParticlePositionPrev[strandParticleBegin].xyz) / _DT;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			if (ENABLE_DISTANCE_FTL)
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz - _DampingFTL * _ParticlePositionCorr[i].xyz) / _DT;
			else
				_ParticleVelocity[i].xyz = (_ParticlePosition[i].xyz - _ParticlePositionPrev[i].xyz) / _DT;
		}
	}
}

#define SPLIT_FTL 0

#define NEW_JACOBI 1
#if NEW_JACOBI
groupshared float4 gs_x[THREAD_GROUP_SIZE + 1];// pad head
groupshared float3 gs_d[THREAD_GROUP_SIZE + 1];// pad head
#else
groupshared float3 gs_x[THREAD_GROUP_SIZE];
groupshared float3 gs_d[THREAD_GROUP_SIZE];
#endif

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	const uint strandIndex = groupIdx.x;
#if LAYOUT_INTERLEAVED
	const uint strandParticleBegin = strandIndex;
	const uint strandParticleStride = _StrandCount;
#else
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;
	const uint strandParticleStride = 1;
#endif
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;
#if NEW_JACOBI

	const uint j = threadIdx + 1;

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	{
		if (threadIdx == 0)
		{
			const float3 rootPosition = _RootPosition[strandIndex].xyz;
			const float3 rootTangent = _RootDirection[strandIndex].xyz;
			{
				gs_x[0] = float4(rootPosition - rootTangent * GetParticleInterval(strandIndex), 0.0);
				gs_x[1] = float4(rootPosition, 0.0);
			}
		}
		else
		{
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = float3(0.0, _Gravity, 0.0);
			{
				gs_x[j] = float4(IntegratePosition(x0, v0, a0), 1.0);
				gs_d[j] = 0;
			}
		}
	}

	// count constraints
	const uint m = (THREAD_GROUP_SIZE - 1) - threadIdx;
	const uint n = max(1,
		(ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION) +
		(ENABLE_DISTANCE) * min(2, 1 + m) +
		//(ENABLE_DISTANCE_LRA) * min(2, 1 + m) +
		(ENABLE_CURVATURE) * min(3, 1 + m) +
#if SPLIT_FTL
		0
#else
		ENABLE_DISTANCE_FTL
#endif
		);
	const float n_inv = 1.0 / n;

	// solve constraints by Jacobi iteration

	float3 d_ftl = 0;

	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			float3 d = 0;

			// solve collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, gs_x[j], d);
				else
					SolveCollisionConstraint(gs_x[j], d);
			}

			// solve distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 nop = 0;

				SolveDistanceConstraint(GetParticleInterval(strandIndex), stiffness, gs_x[j - 1], gs_x[j], nop, d);

				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), stiffness, gs_x[j], gs_x[j + 1], d, nop);
				}
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 nop = 0;

				SolveSelectTriangleBendingConstraint(_BendingCurvature, stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop, nop, d);

				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveSelectTriangleBendingConstraint(_BendingCurvature, stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop, d, nop);

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveSelectTriangleBendingConstraint(_BendingCurvature, stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], d, nop, nop);
					}
				}
			}

			// apply SOR
			d *= _Relaxation;

			// solve distance constraints along strand (FTL)
			if (ENABLE_DISTANCE_FTL)
			{
#if SPLIT_FTL

				float3 d_tmp = 0;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, d_tmp);
				d_ftl += d_tmp;

				// move to next iteration
				gs_x[j].xyz += (d * n_inv) + d_tmp;

#else

				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_tmp = 0;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, d_tmp);
				d_ftl += d_tmp * n_inv;

				// move to next iteration
				gs_x[j].xyz += (d + d_tmp) * n_inv;

#endif
			}
			else
			{
				// move to next iteration
				gs_x[j].xyz += d * n_inv;
			}
		}
	}

	if (ENABLE_DISTANCE_FTL)
	{
		gs_d[j - 1] = d_ftl;
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[j].xyz;

		if (ENABLE_DISTANCE_FTL)
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0 - _DampingFTL * gs_d[j]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[j].xyz - x0) / _DT;
	}

#else
	//---------------------------------- ORIGINAL -----------------------------

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		gs_d[threadIdx] = 0;
	}

	// update position
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	const float3 v0 = _ParticleVelocityPrev[i].xyz + ParticleVolumeImpulse(i, _ParticleVelocityPrev[i].xyz);
	const float3 a0 = float3(0.0, _Gravity, 0.0);
	{
		if (threadIdx == 0)
			gs_x[threadIdx] = _RootPosition[strandIndex].xyz;
		else
			gs_x[threadIdx] = IntegratePosition(x0, v0, a0);
	}

	// solve constraints by Jacobi iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		GroupMemoryBarrierWithGroupSync();

		if (threadIdx > 0)
		{
			uint n = 0;
			float3 d = 0;

			// solve collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, 1.0, gs_x[threadIdx], d);
				else
					SolveCollisionConstraint(1.0, gs_x[threadIdx], d);

				n++;
			}

			// solve distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 nop = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx == 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.0, 1.0, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
				}
				else
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx - 1], gs_x[threadIdx], nop, sum); count++;
					
					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, gs_x[threadIdx], gs_x[threadIdx + 1], sum, nop); count++;
					}
				}

				d += sum * stiffness;
				n += count;
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 nop1 = 0;
				float3 nop2 = 0;
				float3 sum = 0;
				uint count = 0;

				if (threadIdx <= 1)
				{
					const uint j = threadIdx;
					const float3 gs_x_rooted = gs_x[0] - _RootDirection[strandIndex].xyz * GetParticleInterval(strandIndex);

					SolveSelectTriangleBendingConstraint(_BendingCurvature, 1.0, 0.0, 0.0, 1.0, gs_x_rooted, gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;
					SolveSelectTriangleBendingConstraint(_BendingCurvature, 1.0, 0.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					SolveSelectTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
				}
				else
				{
					const uint j = threadIdx;

					SolveSelectTriangleBendingConstraint(_BendingCurvature, 1.0, threadIdx != 2 ? 1.0 : 0.0, 1.0, 1.0, gs_x[j - 2], gs_x[j - 1], gs_x[j], nop1, nop2, sum); count++;

					if (threadIdx < THREAD_GROUP_SIZE - 1)
					{
						SolveSelectTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j - 1], gs_x[j], gs_x[j + 1], nop1, sum, nop2); count++;
					}

					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveSelectTriangleBendingConstraint(_BendingCurvature, 1.0, 1.0, 1.0, 1.0, gs_x[j], gs_x[j + 1], gs_x[j + 2], sum, nop1, nop2); count++;
					}
				}

				d += sum * stiffness;
				n += count;
			}

			// solve distance constraints along strand (FTL)
			if (ENABLE_DISTANCE_FTL)
			{
				//TODO divide 'd' early to reduce averaging of FTL constraint?

				float3 d_pre_ftl = d;
				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[threadIdx - 1], gs_x[threadIdx], d); n++;

				float inv_n = _Relaxation / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
				gs_d[threadIdx - 1] += (d - d_pre_ftl) * inv_n;
			}
			else
			{
				float inv_n = _Relaxation / n;
				gs_x[threadIdx] = gs_x[threadIdx] + d * inv_n;
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// derive velocity from effective change in position
	{
		_ParticlePosition[i].xyz = gs_x[threadIdx];

		if (ENABLE_DISTANCE_FTL)
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0 - _DampingFTL * gs_d[threadIdx]) / _DT;
		else
			_ParticleVelocity[i].xyz = (gs_x[threadIdx] - x0) / _DT;
	}
#endif
}
