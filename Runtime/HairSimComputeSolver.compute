#pragma kernel KInitialize								THREAD_GROUP_SIZE=64	F_INIT
#pragma kernel KInitializePostVolume					THREAD_GROUP_SIZE=64	F_INIT
#pragma kernel KUpdateRoots								THREAD_GROUP_SIZE=64	F_INPUT
#pragma kernel KSubstepRoots							THREAD_GROUP_SIZE=64	F_SUBSTEP
#pragma kernel KSolveConstraints_GaussSeidelReference	THREAD_GROUP_SIZE=64	F_SOLVE
#pragma kernel KSolveConstraints_GaussSeidel			THREAD_GROUP_SIZE=64	F_SOLVE
#pragma kernel KSolveConstraints_Jacobi_16				THREAD_GROUP_SIZE=16	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_16
#pragma kernel KSolveConstraints_Jacobi_32				THREAD_GROUP_SIZE=32	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_32
#pragma kernel KSolveConstraints_Jacobi_64				THREAD_GROUP_SIZE=64	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_64
#pragma kernel KSolveConstraints_Jacobi_128				THREAD_GROUP_SIZE=128	F_SOLVE		KSolveConstraints_Jacobi=KSolveConstraints_Jacobi_128
#pragma kernel KInterpolate								THREAD_GROUP_SIZE=64	F_INTERPOLATE
#pragma kernel KInterpolateNearest						THREAD_GROUP_SIZE=64	F_INTERPOLATE
#pragma kernel KStaging									THREAD_GROUP_SIZE=64	F_STAGING
#pragma kernel KStagingSubdivision						THREAD_GROUP_SIZE=64	F_STAGING

//----------
// features

#pragma multi_compile __ LAYOUT_INTERLEAVED
// 0 == particles grouped by strand, i.e. root, root+1, root, root+1
// 1 == particles grouped by index, i.e. root, root, root+1, root+1

#pragma multi_compile __ STAGING_COMPRESSION
// 0 == staging data full precision
// 1 == staging data compressed

#pragma multi_compile __ APPLY_VOLUME_IMPULSE
// 0 == mute volume impulse, by default the case for secondary substeps (unless application is forced)
// 1 == apply volume impulses, always the case for first substep

#pragma multi_compile __ ENABLE_BOUNDARY// ENABLE_BOUNDARY_FRICTION
#pragma multi_compile __ ENABLE_DISTANCE
#pragma multi_compile __ ENABLE_DISTANCE_LRA
//#pragma multi_compile __ ENABLE_DISTANCE_FTL
//#pragma multi_compile __ ENABLE_CURVATURE_EQ ENABLE_CURVATURE_GEQ ENABLE_CURVATURE_LEQ
#pragma multi_compile __ ENABLE_POSE_LOCAL_BEND_TWIST
#pragma multi_compile __ ENABLE_POSE_GLOBAL_POSITION
//#pragma multi_compile __ ENABLE_POSE_GLOBAL_ROTATION

//------------------
// features derived

#ifndef ENABLE_BOUNDARY
#define ENABLE_BOUNDARY 0
#endif
#ifndef ENABLE_BOUNDARY_FRICTION
#define ENABLE_BOUNDARY_FRICTION 0
#endif
#ifndef ENABLE_DISTANCE
#define ENABLE_DISTANCE 0
#endif
#ifndef ENABLE_DISTANCE_LRA
#define ENABLE_DISTANCE_LRA 0
#endif
#ifndef ENABLE_DISTANCE_FTL
#define ENABLE_DISTANCE_FTL 0
#endif
#ifndef ENABLE_CURVATURE_EQ
#define ENABLE_CURVATURE_EQ 0
#endif
#ifndef ENABLE_CURVATURE_GEQ
#define ENABLE_CURVATURE_GEQ 0
#endif
#ifndef ENABLE_CURVATURE_LEQ
#define ENABLE_CURVATURE_LEQ 0
#endif
#ifndef ENABLE_POSE_LOCAL_BEND_TWIST
#define ENABLE_POSE_LOCAL_BEND_TWIST 0
#endif
#ifndef ENABLE_POSE_GLOBAL_POSITION
#define ENABLE_POSE_GLOBAL_POSITION 0
#endif
#ifndef ENABLE_POSE_GLOBAL_ROTATION
#define ENABLE_POSE_GLOBAL_ROTATION 0
#endif

#ifndef STAGING_COMPRESSION
#define STAGING_COMPRESSION 0
#endif

//-----------------------
// features experimental

#define SECOND_ORDER_UPDATE 0

#if SECOND_ORDER_UPDATE
#define SECOND_ORDER_POSITION 1
#define SECOND_ORDER_VELOCITY 0
#else
#define SECOND_ORDER_POSITION 0
#define SECOND_ORDER_VELOCITY 0
#endif

//----------
// includes

#define HAIRSIM_WRITEABLE_SOLVERINPUT (F_INPUT)
#define HAIRSIM_WRITEABLE_SOLVERDATA (F_INIT || F_SUBSTEP || F_SOLVE || F_INTERPOLATE || F_STAGING)

#include "HairSimData.hlsl"
#include "HairSimComputeConfig.hlsl"
#include "HairSimComputeSolverBoundaries.hlsl"
#include "HairSimComputeSolverConstraints.hlsl"
#include "HairSimComputeSolverQuaternion.hlsl"
#include "HairSimComputeVolumeUtility.hlsl"

//--------
// macros

#define ENABLE_CURVATURE (ENABLE_CURVATURE_EQ || ENABLE_CURVATURE_GEQ || ENABLE_CURVATURE_LEQ)

#if ENABLE_CURVATURE_GEQ
#define ApplyTriangleBendingConstraintSel ApplyTriangleBendingMinConstraint
#define SolveTriangleBendingConstraintSel SolveTriangleBendingMinConstraint
#elif ENABLE_CURVATURE_LEQ
#define ApplyTriangleBendingConstraintSel ApplyTriangleBendingMaxConstraint
#define SolveTriangleBendingConstraintSel SolveTriangleBendingMaxConstraint
#else
#define ApplyTriangleBendingConstraintSel ApplyTriangleBendingConstraint
#define SolveTriangleBendingConstraintSel SolveTriangleBendingConstraint
#endif

#define CHECK_STRAND(x)			\
	if (x >= _StrandCount) return;
#define CHECK_STRAND_SOLVER(x)	\
	if (x >= _SolverStrandCount) return;

#if LAYOUT_INTERLEAVED
  #define DECLARE_STRAND_UNCHECKED(x)				\
	const uint strandIndex = x;						\
	const uint strandParticleBegin = strandIndex;	\
	const uint strandParticleStride = _StrandCount;	\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#else
  #define DECLARE_STRAND_UNCHECKED(x)										\
	const uint strandIndex = x;												\
	const uint strandParticleBegin = strandIndex * _StrandParticleCount;	\
	const uint strandParticleStride = 1;									\
	const uint strandParticleEnd = strandParticleBegin + strandParticleStride * _StrandParticleCount;
#endif

#define DECLARE_STRAND(x)	\
	CHECK_STRAND(x);		\
	DECLARE_STRAND_UNCHECKED(x);

#define DECLARE_STRAND_SOLVER(x)	\
	CHECK_STRAND_SOLVER(x);			\
	DECLARE_STRAND_UNCHECKED(x);

//---------
// utility

float3 ApplyVolumeImpulse(float3 x0, float3 v0)
{
	float3 impulse = 0.0;

#if APPLY_VOLUME_IMPULSE
	{
		float3 uvw = VolumeWorldToUVW(x0);

		// add cell pressure
		{
			impulse += _CellPressure * -VolumeSampleVector(_VolumePressureGrad, uvw);
		}

		// add cell velocity
		{
#if SPLAT_TRILINEAR
			SamplerState ss = _Volume_trilinear_clamp;
#else
			SamplerState ss = _Volume_point_clamp;
#endif
			impulse += _CellVelocity * (VolumeSampleVector(_VolumeVelocity, uvw, ss) - v0);
		}
	}
#endif

	return impulse;
}

float GetIterationStiffness(uint iteration)
{
	//return 1.0 - pow(abs(1.0 - _Stiffness), 1.0 / _Iterations);
	return 1.0 - pow(saturate(1.0 - _Stiffness), 1.0 / (1 + iteration));
}

float GetDecay(float fraction, float interval)
{
	return pow(max(1e-5, 1.0 - fraction), _DT / interval);
}

#define DEFINE_DECAY_FUNCS(T)									\
	T Decay(T a, float fraction, float interval)				\
	{															\
		return a * GetDecay(fraction, interval);				\
	}															\
	T DecayTowards(T a, T b, float fraction, float interval)	\
	{															\
		return lerp(a, b, 1.0 - GetDecay(fraction, interval));	\
	}

DEFINE_DECAY_FUNCS(float);
DEFINE_DECAY_FUNCS(float2);
DEFINE_DECAY_FUNCS(float3);
DEFINE_DECAY_FUNCS(float4);

float3 IntegratePosition(float3 x0, float3 v0, float3 a0)
{
	return x0 + _DT * (v0 + _DT * a0);
}

float3 IntegratePosition_SecondOrder(float3 x0, float3 x0_minus1, float3 v0, float3 v0_minus1, float3 a0)
{
	// second order prediction
	// http://www.cs.ubc.ca/~rbridson/docs/english-siggraph08-cloth.pdf

	return (
		(4.0 / 3.0) * x0 -
		(1.0 / 3.0) * x0_minus1 +
		(8.0 / 9.0) * _DT * v0 -
		(2.0 / 9.0) * _DT * v0_minus1 +
		(4.0 / 9.0) * _DT * _DT * a0
	);
}

float3 DeriveVelocity(float3 x1, float3 x0)
{
	return (x1 - x0) / _DT;
	//TODO clamp?
}

float3 DeriveVelocity_SecondOrder(float3 x1, float3 x0, float3 x0_minus1)
{
	// second order velocity update
	// http://www.cs.ubc.ca/~rbridson/docs/english-siggraph08-cloth.pdf
	
	return (
		(3.0 / 2.0) * x1 -
		(2.0 / 1.0) * x0 +
		(1.0 / 2.0) * x0_minus1
	) / _DT;
}

void DeriveParticleVelocity(uint particleIndex, out float3 x1, out float3 v1)
{
	x1 = _ParticlePosition[particleIndex].xyz;
#if SECOND_ORDER_VELOCITY
	v1 = DeriveVelocity_SecondOrder(x1, _ParticlePositionPrev[particleIndex].xyz, _ParticlePositionPrevPrev[particleIndex].xyz);
#else
	v1 = DeriveVelocity(x1, _ParticlePositionPrev[particleIndex].xyz);
#endif
}

float3 DeriveParticleVelocity(uint particleIndex, float3 x1)
{
#if SECOND_ORDER_VELOCITY
	return DeriveVelocity_SecondOrder(x1, _ParticlePositionPrev[particleIndex].xyz, _ParticlePositionPrevPrev[particleIndex].xyz);
#else
	return DeriveVelocity(x1, _ParticlePositionPrev[particleIndex].xyz);
#endif
}

float3 LinearToAngular(float3 r, float3 v)
{
	float3 w = cross(r, v) / dot(r, r);
	return w;
}

float3 LinearToAngularPoint(float3 pF, float3 vF, float3 p, float3 v)
{
	float3 w = LinearToAngular(p - pF, v - vF);
	return w;
}

float3 AngularToLinear(float3 r, float3 w)
{
	float3 v = cross(w, r);
	return v;
}

float3 AngularToLinearPoint(float3 pF, float3 vF, float3 p, float3 w)
{
	float3 v = vF + AngularToLinear(p - pF, w);
	return v;
}

void ApplyDampingFTL(inout float3 v, float3 d)
{
	v -= (_FTLDamping / _DT) * d;
}

void ApplyDampingLinear(inout float3 v)
{
	v *= GetDecay(_Damping, _DampingInterval);
}

void ApplyDampingAngular(float3 p0, float3 p1, inout float3 v0, inout float3 v1)
{
	if (_AngularDamping > 0.0)
	{
		float3 pF = 0.5 * (p0 + p1);
		float3 vF = 0.5 * (v0 + v1);

		float3 r = p1 - pF;
		float3 v = 1.0 * (v1 - v0);
		float3 w = LinearToAngular(r, v);

		float3 v_tan = AngularToLinear(r, w);
		float3 v_tan_damp = v_tan * (1.0 - GetDecay(_AngularDamping, _AngularDampingInterval));

		v0 += v_tan_damp;
		v1 -= v_tan_damp;
	}
}

void ApplyDampingDistance(float3 p0, float3 p1, inout float3 v0, inout float3 v1)
{
	//TODO separate damping coeff or group with linear/point?
	return;// disabled until then

	float3 n = normalize(p1 - p0);
	float3 v = v1 - v0;

	v0 += 0.5 * n * dot(n, v);
	v1 -= 0.5 * n * dot(n, v);
}

float GetParticleInterval(uint strandIndex)
{
	return _GroupMaxParticleInterval * _RootScale[strandIndex];
}

float GetBendingRadius(uint strandIndex)
{
	return _LocalCurvature * GetParticleInterval(strandIndex);
}

float LinearRamp(float x, float4 ramp)
{
	// ramp.x = x min
	// ramp.y = x ext
	// ramp.z = y min
	// ramp.w = y ext
	return ramp.z + ramp.w * saturate((x - ramp.x) / ramp.y);
}

float4 LinearRampUnpack(uint rampPack)
{
	return saturate(
		float4(
			rampPack >> 24,
			rampPack >> 16,
			rampPack >> 8,
			rampPack
			) / 255.0
	);
}

float LinearRamp(float x, uint rampPack)
{
	return LinearRamp(x, LinearRampUnpack(rampPack));
}

float GetGlobalParamAttenuation(uint strandIndex, uint strandParticleNumber)
{
	float x = _RootScale[strandIndex] * (strandParticleNumber / (float)(_StrandParticleCount - 1));
	return LinearRamp(x, float4(_GlobalFadeOffset, _GlobalFadeExtent, 1.0, -1.0));
}

float GetGlobalPositionInfluence(uint strandIndex, uint strandParticleNumber)
{
	float k = _GlobalPosition * GetGlobalParamAttenuation(strandIndex, strandParticleNumber);
	return 1.0 - GetDecay(k, _GlobalPositionInterval);// fits into lerp(a, b, t), where b is the global position
}

float GetGlobalRotationInfluence(uint strandIndex, uint strandParticleNumber)
{
	float k = _GlobalRotation * GetGlobalParamAttenuation(strandIndex, strandParticleNumber);
	return k;
}

//--------------
// kernels init

#if F_INIT

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitialize(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	// store initial pose
	//TODO move things around here

	float3 rootPos0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 rootPosWorld = _RootPosition[strandIndex].xyz;
	
	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 particleOffset0 = _ParticlePosition[i].xyz - rootPos0;
		float3 particleOffsetWorld = QMul(_WorldRotation, particleOffset0 * _GroupScale);

		_InitialParticleOffset[i].xyz = particleOffset0;

		_ParticlePosition[i].xyz = (rootPosWorld + particleOffsetWorld);
		_ParticlePositionPrev[i].xyz = (rootPosWorld + particleOffsetWorld);
		_ParticlePositionPrevPrev[i].xyz = (rootPosWorld + particleOffsetWorld);
		_ParticleVelocity[i] = float4(0.0, 0.0, 0.0, _GroupMaxParticleInterval * _RootScale[strandIndex]);
		_ParticleVelocityPrev[i] = float4(0.0, 0.0, 0.0, _GroupMaxParticleInterval * _RootScale[strandIndex]);
	}

	// calc initial strand root material frame
	{
		float3 rootDir0 = normalize(_InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz);
		float3 rootDirMaterialFrame = float3(0.0, 1.0, 0.0);

		_InitialRootFrame[strandIndex] = MakeQuaternionFromTo(rootDirMaterialFrame, rootDir0);
	}

	// calc initial particle material frame deltas
	{
		float4 rootFrame = _InitialRootFrame[strandIndex];
		float4 rootFrameInv = QInverse(rootFrame);

		// root
		_InitialParticleFrameDelta[strandParticleBegin] = MakeQuaternionIdentity();//TODO might as well store root frame here?
	
		// root+1
		float3 r0 = -float3(0.0, 1.0, 0.0);
		float3 r1 = 0.0;
		float3 r2 = QMul(rootFrameInv, _InitialParticleOffset[strandParticleBegin + strandParticleStride].xyz);
		{
			_InitialParticleFrameDelta[strandParticleBegin + strandParticleStride] = MakeQuaternionFromBend(r0, r1, r2);
		}
		
		// root+2..
		for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
		{
			r0 = r1;
			r1 = r2;
			r2 = QMul(rootFrameInv, _InitialParticleOffset[i].xyz);

			_InitialParticleFrameDelta[i] = normalize(QMul(MakeQuaternionFromBend(r0, r1, r2), _InitialParticleFrameDelta[i - strandParticleStride]));
		}

		// reverse to finalize
		{
			for (uint i = strandParticleEnd - strandParticleStride; i != strandParticleBegin; i -= strandParticleStride)
			{
				float4 q0 = _InitialParticleFrameDelta[i - strandParticleStride];
				float4 q1 = _InitialParticleFrameDelta[i];

				_InitialParticleFrameDelta[i] = normalize(QMul(QInverse(q0), q1));
			}
		}
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInitializePostVolume(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);
	
	for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
	{
		float3 uvw = VolumeWorldToUVW(_ParticlePosition[i].xyz);
		float accu_w = _VolumeVelocity.SampleLevel(_Volume_trilinear_clamp, uvw, 0).w;

		// estimate pre-insertion value given trilinear sample and trilinear weights
		{
			accu_w *= VolumeWorldToCellTrilinearInverseMultiplier(_ParticlePosition[i].xyz);
		}

		_ParticlePosition[i].w = accu_w;//TODO pack elsewhere?
		_ParticlePositionPrev[i].w = accu_w;
		_ParticlePositionPrevPrev[i].w = accu_w;

		// NOTE: deferred from pre-volume init to satisfy DX11 limit on active UAVs
		_ParticlePositionCorr[i].xyz = 0.0;
	}
}

#endif//F_INIT

//---------------
// kernels input

#if F_INPUT

ByteAddressBuffer _VertexBufferPosition;
ByteAddressBuffer _VertexBufferNormal;

uint _VertexBufferPositionOffset;
uint _VertexBufferPositionStride;
uint _VertexBufferNormalOffset;
uint _VertexBufferNormalStride;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KUpdateRoots(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	uint addressPosition = strandIndex * _VertexBufferPositionStride + _VertexBufferPositionOffset;
	uint addressNormal = strandIndex * _VertexBufferNormalStride + _VertexBufferNormalOffset;

	float3 positionOS = asfloat(_VertexBufferPosition.Load3(addressPosition));
	float3 normalOS = asfloat(_VertexBufferNormal.Load3(addressNormal));

	_RootPosition[strandIndex].xyz = mul(_LocalToWorld, float4(positionOS, 1.0)).xyz;
	_RootDirection[strandIndex].xyz = normalize(mul(_LocalToWorldInvT, float4(normalOS, 0.0)).xyz);
	_RootFrame[strandIndex] = normalize(QMul(_WorldRotation, _InitialRootFrame[strandIndex]));
}

#endif//F_INPUT

//-----------------
// kernels substep

#if F_SUBSTEP

float3 BlendPosition(float3 p0, float3 p1, float t)
{
	return lerp(p0, p1, t);
}

float3 BlendDirection(float3 v0, float3 v1, float t)
{
	float4 q0 = MakeQuaternionIdentity();
	float4 q1 = MakeQuaternionFromTo(v0, v1);
	float4 qt = QSlerp(q0, q1, t);
	return QMul(qt, v0);
}

float4 BlendQuaternion(float4 q0, float4 q1, float t)
{
	return QSlerp(q0, q1, t);
}

float _SubstepFraction;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSubstepRoots(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	_SubstepRootPosition[strandIndex].xyz = BlendPosition(
		_RootPositionPrev[strandIndex].xyz,
		_RootPosition[strandIndex].xyz,
		_SubstepFraction);

	_SubstepRootDirection[strandIndex].xyz = BlendDirection(
		_RootDirectionPrev[strandIndex].xyz,
		_RootDirection[strandIndex].xyz,
		_SubstepFraction);

	_SubstepRootFrame[strandIndex] = BlendQuaternion(
		_RootFramePrev[strandIndex],
		_RootFrame[strandIndex],
		_SubstepFraction);
}

#endif//F_SUBSTEP

//---------------
// kernels solve

#if F_SOLVE

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidelReference(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_SOLVER(worldIdx.x);

	// update positions
	{
		_ParticlePosition[strandParticleBegin].xyz = _RootPosition[strandIndex].xyz;

		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ApplyVolumeImpulse(x0, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = _WorldGravity.xyz;
			{
#if SECOND_ORDER_POSITION
				const float3 x0_minus1 = _ParticlePositionPrevPrev[i].xyz;
				const float3 v0_minus1 = _ParticleVelocity[i].xyz;
				_ParticlePosition[i].xyz = IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0);
#else
				_ParticlePosition[i].xyz = IntegratePosition(x0, v0, a0);
#endif
			}
		}
	}

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i].xyz = 0;
		}
	}

	// apply global position constraints
	if (ENABLE_POSE_GLOBAL_POSITION)
	{
		float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			float3 r0 = _ParticlePosition[i].xyz - p0;
			float3 r1 = QMul(_WorldRotation, _InitialParticleOffset[i].xyz * _GroupScale);

			_ParticlePosition[i].xyz = p0 + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, k));
		}
	}

	// solve constraints by Gauss-Seidel iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		const float stiffness = GetIterationStiffness(__iteration);

		// solve boundary collision constraints
		if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
		{
			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, _ParticlePosition[i].xyz);
				else
					ApplyCollisionConstraint(_ParticlePosition[i].xyz);
			}
		}

		// solve particle-particle distance constraints
		if (ENABLE_DISTANCE)
		{
			// root+1
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;

			ApplyDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.0, 1.0, p0, p1);

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				ApplyDistanceConstraint(GetParticleInterval(strandIndex), 1.0, 0.5, 0.5, p0, p1);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve 'long range attachment' distance constraints
		if (ENABLE_DISTANCE_LRA)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			// root+1..
			for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				float3 p1 = _ParticlePosition[i].xyz;

				ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, p0, p1);

				_ParticlePosition[i].xyz = p1;
			}
		}

		// solve triangle bending constraints
		if (ENABLE_CURVATURE)
		{
			float4 rootFrame = _RootFrame[strandIndex];
			float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
			float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
			float3 p2 = _ParticlePosition[strandParticleBegin + strandParticleStride * 2].xyz;
			float3 r0 = p0 - rootVec;

			//      p1 <-- solve
			//     /
			//--- p0 <-- fixed (root)
			//    |
			//    r0 <-- fixed (root-1)
			ApplyTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, 0.0, 0.0, 1.0, r0, p0, p1);

			//      p2 <-- solve
			//     /
			//    p1 <-- solve
			//    |
			//--- p0 <-- fixed (root)
			//    |
			//    ##
			ApplyTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, 0.0, 1.0, 1.0, p0, p1, p2);

			for (uint i = strandParticleBegin + strandParticleStride * 3; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = _ParticlePosition[i].xyz;

				//      p2 <-- solve
				//     /
				//    p1 <-- solve
				//    |
				//    p0 <-- solve
				//    |
				//--- ##
				ApplyTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, 1.0, 1.0, 1.0, p0, p1, p2);

				_ParticlePosition[i - strandParticleStride * 2].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p1;
			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p2;
		}

		// solve global rotation constraints
		if (ENABLE_POSE_GLOBAL_ROTATION)
		{
			float4 rootFrame = _RootFrame[strandIndex];
			float3 rootPos = _RootPosition[strandIndex].xyz;
			float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

			// root
			float3 p0 = rootPos - rootVec;
			float3 p1 = rootPos;

			float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;

				p0 = rootPos;
				p1 = _ParticlePosition[i].xyz;

				accuFrame = QMul(accuFrame, _InitialParticleFrameDelta[i]);

				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, 1), 0.0, 1.0, 0.0, p0, p1, accuFrame);
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2, k = 2; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				p0 = p1;
				p1 = _ParticlePosition[i].xyz;

				accuFrame = QMul(accuFrame, _InitialParticleFrameDelta[i]);

				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), 1.0, 1.0, 0.0, p0, p1, accuFrame);

				_ParticlePosition[i - strandParticleStride].xyz = p0;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p1;
		}

		// solve local shape constraints
		if (ENABLE_POSE_LOCAL_BEND_TWIST)
		{
			float4 rootFrame = _RootFrame[strandIndex];
			float3 rootPos = _RootPosition[strandIndex].xyz;
			float3 rootDir = QMul(rootFrame, float3(0, 1, 0));

			// root
			float3 p0 = rootPos - rootDir * GetParticleInterval(strandIndex) * 3.0;
			float3 p1 = rootPos - rootDir * GetParticleInterval(strandIndex) * 2.0;
			float3 p2 = rootPos - rootDir * GetParticleInterval(strandIndex);
			float3 p3 = rootPos;

			float4 q2 = MakeQuaternionIdentity();
			float4 q3 = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			float4 accuFrame = QMul(rootFrame, _InitialParticleFrameDelta[strandParticleBegin]);

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;

				p0 = p1;// root-2
				p1 = p2;// root-1
				p2 = p3;// root
				p3 = _ParticlePosition[i].xyz;

				q2 = q3;// root frame
				q3 = QMul(MakeQuaternionFromBend(p1, p2, p3), q2);

				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, 0.0f, 1.0f, q2, q3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 0.0f, 1.0f, 1.0f, p2, p3, q3);
			}

			// root+2..
			for (uint i = strandParticleBegin + strandParticleStride * 2; i != strandParticleEnd; i += strandParticleStride)
			{
				p0 = p1;
				p1 = p2;
				p2 = p3;
				p3 = _ParticlePosition[i].xyz;

				q2 = q3;
				q3 = QMul(MakeQuaternionFromBend(p1, p2, p3), q2);

				ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, 1.0f, 1.0f, q2, q3);
				ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, 1.0f, 1.0f, 1.0f, p2, p3, q3);

				_ParticlePosition[i - strandParticleStride].xyz = p2;
			}

			_ParticlePosition[strandParticleEnd - strandParticleStride].xyz = p3;
		}

		// solve 'follow the leader' distance constraints
		if (ENABLE_DISTANCE_FTL)
		{
			float3 p0 = _ParticlePosition[strandParticleBegin].xyz;

			for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
			{
				float3 p1 = _ParticlePosition[i].xyz;
				float3 d1 = 0;

				ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p0, p1, d1);
				
				_ParticlePosition[i].xyz = p1;
				_ParticlePositionCorr[i - strandParticleStride].xyz += d1;// correction to particle above current particle

				p0 = p1;
			}
		}
	}

	// update velocities
	{
		// root
		float3 p0;
		float3 v0;
		DeriveParticleVelocity(strandParticleBegin, p0, v0);

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			float3 p1;
			float3 v1;
			DeriveParticleVelocity(i, p1, v1);

			if (ENABLE_DISTANCE_FTL)
			{
				ApplyDampingFTL(v1, _ParticlePositionCorr[i].xyz);
			}

			ApplyDampingLinear(v1);
			ApplyDampingAngular(p0, p1, v0, v1);
			ApplyDampingDistance(p0, p1, v0, v1);

			_ParticleVelocity[i - strandParticleStride].xyz = v0;

			p0 = p1;
			v0 = v1;
		}

		// ..n-1
		_ParticleVelocity[strandParticleEnd - strandParticleStride].xyz = v0;
	}
}

#define GS_REPEAT_BEND_TWIST 0

#if ENABLE_CURVATURE || (ENABLE_POSE_LOCAL_BEND_TWIST && GS_REPEAT_BEND_TWIST)
#define GS_LIVE_CONSTRAINTS 3
#elif ENABLE_DISTANCE || ENABLE_POSE_GLOBAL_ROTATION || ENABLE_POSE_LOCAL_BEND_TWIST
#define GS_LIVE_CONSTRAINTS 2
#else
#define GS_LIVE_CONSTRAINTS 1
#endif

struct PartialStrandPos
{
	float3 minus3;// ..
	float3 minus2;// ..
	float3 minus1;// head-1
	float3 minus0;// head
};

struct PartialStrandRot
{
	float4 minus2;// ..
	float4 minus1;// head-1
	float4 minus0;// head
	float4 minus0_global;
};

void PartialStrand_SolveNext(
	inout PartialStrandPos p, inout PartialStrandRot q,
	const uint strandIndex, const uint strandParticleStride,
	const float3 rootPos,
	const uint i, const uint k, const float stiffness,
	const float w_minus2, const float w_minus1, const float w_minus0)
{
	p.minus3 = p.minus2;
	p.minus2 = p.minus1;
	p.minus1 = p.minus0;
	p.minus0 = _ParticlePosition[i].xyz;

	q.minus2 = q.minus1;
	q.minus1 = q.minus0;
	q.minus0 = QMul(MakeQuaternionFromBend(p.minus2, p.minus1, p.minus0), q.minus1);
	q.minus0_global = QMul(q.minus0_global, _InitialParticleFrameDelta[i]);

	if (ENABLE_POSE_GLOBAL_ROTATION)
	{
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, k), w_minus1, w_minus0, 0.0, p.minus1, p.minus0, q.minus0_global);
	}

	// GS_LIVE_CONSTRAINTS == 3
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                       `--------- solve ---------´
	//
	// GS_LIVE_CONSTRAINTS == 2
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                     `-- solve --´
	//
	// GS_LIVE_CONSTRAINTS == 1
	//                                                 load
	//                           (q1)          (q0)     |
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                                   `-- solve

	if (ENABLE_BOUNDARY)			ApplyCollisionConstraint(p.minus0);
	if (ENABLE_BOUNDARY_FRICTION)	ApplyCollisionFrictionConstraint(_BoundaryFriction, _ParticlePositionPrev[i].xyz, p.minus0);
	if (ENABLE_DISTANCE_LRA)		ApplyDistanceLRAConstraint(GetParticleInterval(strandIndex) * k, rootPos, p.minus0);
	if (ENABLE_DISTANCE)			ApplyDistanceConstraint(GetParticleInterval(strandIndex), 1.0, w_minus1, w_minus0, p.minus1, p.minus0);
	if (ENABLE_CURVATURE)			ApplyTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, w_minus2, w_minus1, w_minus0, p.minus2, p.minus1, p.minus0);

	if (ENABLE_POSE_LOCAL_BEND_TWIST)
	{
#if GS_REPEAT_BEND_TWIST
		float wq_minus2 = 0.5 * w_minus2;
		float wq_minus1 = 0.5 * (w_minus2 + w_minus1);
		float wq_minus0 = 0.5 * (w_minus1 + w_minus0);

		ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i - 1 * strandParticleStride], stiffness * _LocalShape, wq_minus2, wq_minus1, q.minus2, q.minus1);
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus2, w_minus1, wq_minus1, p.minus2, p.minus1, q.minus1);

		ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i - 0 * strandParticleStride], stiffness * _LocalShape, wq_minus1, wq_minus0, q.minus1, q.minus0);
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus1, w_minus0, wq_minus0, p.minus1, p.minus0, q.minus0);
#else
		float wq_minus1 = 0.5 * (w_minus2 + w_minus1);
		float wq_minus0 = 0.5 * (w_minus1 + w_minus0);

		ApplyMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, wq_minus1, wq_minus0, q.minus1, q.minus0);

	#if 0
		float3 v0 = QMul(q.minus1, float3(0, GetParticleInterval(strandIndex), 0));
		float3 v1 = QMul(q.minus0, float3(0, GetParticleInterval(strandIndex), 0));
		ApplyDualEdgeVectorConstraint(
			v0, v1, stiffness * _LocalShape,
			w_minus2, w_minus1, w_minus0,
			p.minus2, p.minus1, p.minus0
		);
	#else
		ApplyMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, w_minus1, w_minus0, wq_minus0, p.minus1, p.minus0, q.minus0);
	#endif
#endif
	}

	// GS_LIVE_CONSTRAINTS == 3
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//    (anchor)          |`-- done      `-- active ---´
	//                      |
	//                     write
	//
	// GS_LIVE_CONSTRAINTS == 2
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                  (anchor)          |`-- done      `-- active
	//                                    |
	//                                   write
	//
	// GS_LIVE_CONSTRAINTS == 1
	//
	//                           (q1)          (q0)
	// - --- p3 ---------- p2 ---------- p1 ---------- p0
	//                                (anchor)          |`-- done
	//                                                  |
	//                                                 write

	if (ENABLE_DISTANCE_FTL)
	{
		if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus3, p.minus2, _ParticlePositionCorr[i - strandParticleStride * 3].xyz);
		if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus2, p.minus1, _ParticlePositionCorr[i - strandParticleStride * 2].xyz);
		if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus1, p.minus0, _ParticlePositionCorr[i - strandParticleStride * 1].xyz);
	}

	if ((GS_LIVE_CONSTRAINTS == 3) && (w_minus2 != 0.0)) _ParticlePosition[i - strandParticleStride * 2].xyz = p.minus2;
	if ((GS_LIVE_CONSTRAINTS == 2) && (w_minus1 != 0.0)) _ParticlePosition[i - strandParticleStride * 1].xyz = p.minus1;
	if ((GS_LIVE_CONSTRAINTS == 1) && (w_minus0 != 0.0)) _ParticlePosition[i - strandParticleStride * 0].xyz = p.minus0;
}

void PartialStrand_SolveTail(inout PartialStrandPos p, const uint strandIndex, const uint strandParticleStride, const uint strandParticleEnd)
{
	if (ENABLE_DISTANCE_FTL)
	{
		if (GS_LIVE_CONSTRAINTS >= 3) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus2, p.minus1, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 3].xyz);
		if (GS_LIVE_CONSTRAINTS >= 2) ApplyDistanceFTLConstraint(GetParticleInterval(strandIndex), p.minus1, p.minus0, _ParticlePositionCorr[strandParticleEnd - strandParticleStride * 2].xyz);
	}

	if (GS_LIVE_CONSTRAINTS >= 3) _ParticlePosition[strandParticleEnd - strandParticleStride * 2].xyz = p.minus1;
	if (GS_LIVE_CONSTRAINTS >= 2) _ParticlePosition[strandParticleEnd - strandParticleStride * 1].xyz = p.minus0;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_GaussSeidel(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_SOLVER(worldIdx.x);

#if DEBUG_STRAND_31_32
	if (strandIndex < 31 || strandIndex > 32)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePosition[i] = 1e+7;
		}
		return;
	}
#endif

	// update positions
	const float3 rootPos = _RootPosition[strandIndex].xyz;
	{
		// root
		_ParticlePosition[strandParticleBegin].xyz = rootPos;

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride, k = 1; i != strandParticleEnd; i += strandParticleStride, k++)
		{
			const float3 x0 = _ParticlePositionPrev[i].xyz;
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ApplyVolumeImpulse(x0, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = _WorldGravity.xyz;
			{
#if SECOND_ORDER_POSITION
				const float3 x0_minus1 = _ParticlePositionPrevPrev[i].xyz;
				const float3 v0_minus1 = _ParticleVelocity[i].xyz;
				float3 x1_pre = IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0);
#else
				float3 x1_pre = IntegratePosition(x0, v0, a0);
#endif

				// solve global position constraints
				if (ENABLE_POSE_GLOBAL_POSITION)
				{
					const float3 r0 = x1_pre - rootPos;
					const float3 r1 = QMul(_WorldRotation, _InitialParticleOffset[i].xyz * _GroupScale);

					x1_pre = rootPos + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, k));
				}

				_ParticlePosition[i].xyz = x1_pre;
			}
		}
	}

	// clear corrections
	if (ENABLE_DISTANCE_FTL)
	{
		for (uint i = strandParticleBegin; i != strandParticleEnd; i += strandParticleStride)
		{
			_ParticlePositionCorr[i] = 0;
		}
	}

	// solve constraints by Gauss-Seidel iteration
	{
		float4 rootFrame = _RootFrame[strandIndex];
		float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

		for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
		{
			const float stiffness = GetIterationStiffness(__iteration);

			PartialStrandPos p;
			p.minus3 = rootPos - rootVec * 3.0;
			p.minus2 = rootPos - rootVec * 2.0;
			p.minus1 = rootPos - rootVec * 1.0;
			p.minus0 = rootPos;

			PartialStrandRot q;
			q.minus2 = MakeQuaternionIdentity();
			q.minus1 = MakeQuaternionIdentity();
			q.minus0 = rootFrame;
			q.minus0_global = rootFrame;

			// root+1
			{
				const uint i = strandParticleBegin + strandParticleStride;
				const uint k = 1;

				PartialStrand_SolveNext(p, q, strandIndex, strandParticleStride, rootPos, i, k, stiffness, 0.0, 0.0, 1.0);
			}

			// root+2
			{
				const uint i = strandParticleBegin + strandParticleStride * 2;
				const uint k = 2;

				PartialStrand_SolveNext(p, q, strandIndex, strandParticleStride, rootPos, i, k, stiffness, 0.0, 1.0, 1.0);
			}

			// root+3..
			for (uint i = strandParticleBegin + strandParticleStride * 3, k = 3; i != strandParticleEnd; i += strandParticleStride, k++)
			{
				PartialStrand_SolveNext(p, q, strandIndex, strandParticleStride, rootPos, i, k, stiffness, 1.0, 1.0, 1.0);
			}

			// ..n-2, n-1
			PartialStrand_SolveTail(p, strandIndex, strandParticleStride, strandParticleEnd);
		}
	}

	// update velocities
	{
		// root
		float3 p0;
		float3 v0;
		DeriveParticleVelocity(strandParticleBegin, p0, v0);

		// root+1..
		for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd; i += strandParticleStride)
		{
			float3 p1;
			float3 v1;
			DeriveParticleVelocity(i, p1, v1);

			if (ENABLE_DISTANCE_FTL)
			{
				ApplyDampingFTL(v1, _ParticlePositionCorr[i].xyz);
			}

			ApplyDampingLinear(v1);
			ApplyDampingAngular(p0, p1, v0, v1);
			ApplyDampingDistance(p0, p1, v0, v1);

			_ParticleVelocity[i - strandParticleStride].xyz = v0;

			p0 = p1;
			v0 = v1;
		}

		// ..n-1
		_ParticleVelocity[strandParticleEnd - strandParticleStride].xyz = v0;
	}
}

// pad head so that index 0 == root-1
groupshared float4 gs_x[1 + THREAD_GROUP_SIZE];// xyz: position, w: weight
groupshared float4 gs_q[1 + THREAD_GROUP_SIZE];// quat(xyz,w): material frame
groupshared float3 gs_d[1 + THREAD_GROUP_SIZE];// xyz: ftl correction

// one thread group per strand
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KSolveConstraints_Jacobi(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND_SOLVER(groupIdx.x);

	const uint i = strandParticleBegin + strandParticleStride * threadIdx;
	const uint j = threadIdx + 1;// for data in group shared memory (gs_*)

	// update positions
	const float3 x0 = _ParticlePositionPrev[i].xyz;
	{
		// [threads: root]
		if (threadIdx == 0)
		{
			const float4 rootFrame = _RootFrame[strandIndex];
			const float3 rootPos = _RootPosition[strandIndex].xyz;
			const float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));
			{
				gs_x[0] = float4(rootPos - rootVec, 0.0);
				gs_x[1] = float4(rootPos, 0.0);
			}
		}
		// [threads: root+1..]
		else
		{
			const float3 v0 = _ParticleVelocityPrev[i].xyz + ApplyVolumeImpulse(x0, _ParticleVelocityPrev[i].xyz);
			const float3 a0 = _WorldGravity.xyz;
			{
#if SECOND_ORDER_POSITION
				const float3 x0_minus1 = _ParticlePositionPrevPrev[i].xyz;
				const float3 v0_minus1 = _ParticleVelocity[i].xyz;
				gs_x[j] = float4(IntegratePosition_SecondOrder(x0, x0_minus1, v0, v0_minus1, a0), 1.0);
#else
				gs_x[j] = float4(IntegratePosition(x0, v0, a0), 1.0);
#endif
			}
		}
	}

	// clear corrections
	{
		// [threads: root]
		if (threadIdx == 0)
		{
			gs_d[0] = 0;
			gs_d[1] = 0;
		}
		// [threads: root+1..]
		else
		{
			gs_d[j] = 0;
		}
	}

	// build material frames
	{
		GroupMemoryBarrierWithGroupSync();

		// [threads: root]
		if (threadIdx == 0)
		{
			gs_q[0] = MakeQuaternionIdentity();
			gs_q[1] = _RootFrame[strandIndex];
		}
		// [threads: root+1..]
		else
		{
			gs_q[j] = MakeQuaternionFromBend(gs_x[j - 2].xyz, gs_x[j - 1].xyz, gs_x[j].xyz);
		}

		for (uint i = 0; i < THREAD_GROUP_SIZE; i++)
		{
			GroupMemoryBarrierWithGroupSync();

			if (i == threadIdx)
			{
				gs_q[j] = QMul(gs_q[j], gs_q[j - 1]);
				// e.g.
				// thread 0 writes: gs_q[0] = q_rot_0
				// thread 1 writes: gs_q[1] = QMul(q_rot_1, q_rot_0);
				// thread 2 writes: gs_q[2] = QMul(q_rot_2, QMul(q_rot_1, q_rot_0));
				// etc.
			}
		}
	}

	// solve global position constraints
	if (ENABLE_POSE_GLOBAL_POSITION)
	{
		GroupMemoryBarrierWithGroupSync();

		// [threads: root+1..]
		if (threadIdx > 0)
		{
			float3 r0 = gs_x[j].xyz - gs_x[1].xyz;
			float3 r1 = QMul(_WorldRotation, _InitialParticleOffset[i].xyz * _GroupScale);

			gs_x[j].xyz = gs_x[1].xyz + lerp(r0, r1, GetGlobalPositionInfluence(strandIndex, threadIdx));
		}
	}

	// count tailing particles
	const uint num_tailing = (THREAD_GROUP_SIZE - 1) - threadIdx;

	// count acting constraints
	const uint num_acting_x = max(1,
		(ENABLE_BOUNDARY				? 1							: 0) +
		(ENABLE_BOUNDARY_FRICTION		? 1							: 0) +
		(ENABLE_DISTANCE				? min(2, 1 + num_tailing)	: 0) +
		(ENABLE_DISTANCE_LRA			? 1							: 0) +
		(ENABLE_DISTANCE_FTL			? 1							: 0) +
		(ENABLE_CURVATURE				? min(3, 1 + num_tailing)	: 0) +
		(ENABLE_POSE_LOCAL_BEND_TWIST	? min(2, 1 + num_tailing)	: 0) +
		(ENABLE_POSE_GLOBAL_ROTATION	? min(2, 1 + num_tailing)	: 0) +
		0);

	const uint num_acting_q = max(1,
		(ENABLE_POSE_LOCAL_BEND_TWIST	? min(3, 2 + num_tailing)	: 0) +
		(ENABLE_POSE_GLOBAL_ROTATION	? 1							: 0) +
		0);

	// solve constraints by Jacobi iteration
	for (uint __iteration = 0; __iteration != _Iterations; __iteration++)
	{
		GroupMemoryBarrierWithGroupSync();

		const float stiffness = GetIterationStiffness(__iteration);

		// [threads: root+1..]
		if (threadIdx > 0)
		{
			float3 corr_x = 0;
			float4 corr_q = 0;

			// solve boundary collision constraints
			if (ENABLE_BOUNDARY || ENABLE_BOUNDARY_FRICTION)
			{
				if (ENABLE_BOUNDARY_FRICTION)
					SolveCollisionFrictionConstraint(_BoundaryFriction, x0, gs_x[j], corr_x);
				else
					SolveCollisionConstraint(gs_x[j], corr_x);
			}

			// solve particle-particle distance constraints
			if (ENABLE_DISTANCE)
			{
				float3 NOP;
				
				SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, gs_x[j - 1], gs_x[j], NOP, corr_x);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveDistanceConstraint(GetParticleInterval(strandIndex), 1.0, gs_x[j], gs_x[j + 1], corr_x, NOP);
				}
			}

			// solve 'long range attachment' distance constraints
			if (ENABLE_DISTANCE_LRA)
			{
				SolveDistanceLRAConstraint(GetParticleInterval(strandIndex) * threadIdx, gs_x[1].xyz, gs_x[j].xyz, corr_x);
			}

			// solve triangle bending constraints
			if (ENABLE_CURVATURE)
			{
				float3 NOP;

				SolveTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, gs_x[j - 2], gs_x[j - 1], gs_x[j], NOP, NOP, corr_x);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					SolveTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, gs_x[j - 1], gs_x[j], gs_x[j + 1], NOP, corr_x, NOP);

					// [threads: ..end-2]
					if (threadIdx < THREAD_GROUP_SIZE - 2)
					{
						SolveTriangleBendingConstraintSel(GetBendingRadius(strandIndex), stiffness, gs_x[j], gs_x[j + 1], gs_x[j + 2], corr_x, NOP, NOP);
					}
				}
			}

			/* TODO
			// solve global rotation constraints
			if (ENABLE_POSE_GLOBAL_ROTATION)
			{
				float4 NOP;

				float4 q_j = QMul(gs_q[j - 1], _InitialParticleFrameDelta[i]);
				float4 q_j_corr = 0;

				SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, threadIdx), gs_x[j - 1].w, gs_x[j].w, 0.0, gs_x[j - 1].xyz, gs_x[j].xyz, q_j, NOP.xyz, corr_x, q_j_corr);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					float4 q_j_plus_1 = QMul(gs_q[j], _InitialParticleFrameDelta[i + strandParticleStride]);

					SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * GetGlobalRotationInfluence(strandIndex, threadIdx), gs_x[j].w, gs_x[j + 1].w, 0.0, gs_x[j].xyz, gs_x[j + 1].xyz, q_j_plus_1, corr_x, NOP.xyz, NOP);
				}

				corr_q += (q_j + q_j_corr - gs_q[j]) / _SOR;
			}
			*/

			// solve local shape constraints
			if (ENABLE_POSE_LOCAL_BEND_TWIST)
			{
				float4 NOP;

				const float wq_minus1 = 0.5 * (gs_x[j - 2].w + gs_x[j - 1].w);
				const float wq_minus0 = 0.5 * (gs_x[j - 1].w + gs_x[j - 0].w);

				SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i], stiffness * _LocalShape, wq_minus1, wq_minus0, gs_q[j - 1], gs_q[j], NOP, corr_q);
				SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, gs_x[j - 1].w, gs_x[j].w, wq_minus0, gs_x[j - 1].xyz, gs_x[j].xyz, gs_q[j], NOP.xyz, corr_x, corr_q);

				// [threads: ..end-1]
				if (threadIdx < THREAD_GROUP_SIZE - 1)
				{
					float wq_plus1 = 0.5 * (gs_x[j].w + gs_x[j + 1].w);

					SolveMaterialFrameBendTwistConstraint(_InitialParticleFrameDelta[i + strandParticleStride], stiffness * _LocalShape, wq_minus0, wq_plus1, gs_q[j], gs_q[j + 1], corr_q, NOP);
					SolveMaterialFrameStretchShearConstraint(GetParticleInterval(strandIndex), stiffness * _LocalShape, gs_x[j].w, gs_x[j + 1].w, wq_plus1, gs_x[j].xyz, gs_x[j + 1].xyz, gs_q[j + 1], corr_x, NOP.xyz, NOP);
				}
			}

			// apply SOR and averaging
			corr_x *= _SOR / num_acting_x;
			corr_q *= _SOR / num_acting_q;

			// solve 'follow the leader' distance constraints
			if (ENABLE_DISTANCE_FTL)
			{
				float3 corr_x_ftl = 0;

				SolveDistanceFTLConstraint(GetParticleInterval(strandIndex), gs_x[j - 1].xyz, gs_x[j].xyz, corr_x_ftl);

				corr_x_ftl *= 0.5 / num_acting_x;
				corr_x += corr_x_ftl;

				gs_d[j - 1] += corr_x_ftl;// correction to particle above current particle
			}

			// move to next iteration
			gs_x[j].xyz += corr_x;
			gs_q[j] = normalize(gs_q[j] + corr_q);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// store positions
	{
		_ParticlePosition[i].xyz = gs_x[j].xyz;
	}

	// update velocities
	{
#if SECOND_ORDER_VELOCITY
		float3 v = DeriveVelocity_SecondOrder(gs_x[j].xyz, x0, _ParticlePositionPrevPrev[i].xyz);
#else
		float3 v = DeriveVelocity(gs_x[j].xyz, x0);
#endif

		if (ENABLE_DISTANCE_FTL)
		{
			ApplyDampingFTL(v, gs_d[j]);
		}

		ApplyDampingLinear(v);
		//TODO angular damping in jacobi kernel
		//ApplyDampingAngular(p0, p1, v0, v1);
		//ApplyDampingDistance(p0, p1, v0, v1);

		_ParticleVelocity[i].xyz = v;
	}
}

#endif//F_SOLVE

//---------------------
// kernels interpolate

#if F_INTERPOLATE

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInterpolate(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x + _SolverStrandCount);

	uint strandIndexLo = _LODGuideIndex[(_LODIndexLo * _StrandCount) + strandIndex];
	uint strandIndexHi = _LODGuideIndex[(_LODIndexHi * _StrandCount) + strandIndex];

#if LAYOUT_INTERLEAVED
	const uint strandParticleBeginLo = strandIndexLo;
	const uint strandParticleBeginHi = strandIndexHi;
#else
	const uint strandParticleBeginLo = strandIndexLo * _StrandParticleCount;
	const uint strandParticleBeginHi = strandIndexHi * _StrandParticleCount;
#endif

	float strandContribLo = _RootScale[strandIndex] / _RootScale[strandIndexLo];
	float strandContribHi = _RootScale[strandIndex] / _RootScale[strandIndexHi];

	float3 rootPositionLo = _RootPosition[strandIndexLo].xyz;
	float3 rootPositionHi = _RootPosition[strandIndexHi].xyz;
	float3 rootPosition = _RootPosition[strandIndex].xyz;

	_ParticlePosition[strandParticleBegin].xyz = rootPosition;
	_ParticleVelocity[strandParticleBegin].xyz = DeriveParticleVelocity(strandParticleBegin, rootPosition);

	for (uint i = strandParticleBegin + strandParticleStride, iLo = strandParticleBeginLo + strandParticleStride, iHi = strandParticleBeginHi + strandParticleStride; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride, iHi += strandParticleStride)
	{
		float3 initialOffsetLo = QMul(_WorldRotation, _InitialParticleOffset[iLo].xyz) * _GroupScale;
		float3 initialOffsetHi = QMul(_WorldRotation, _InitialParticleOffset[iHi].xyz) * _GroupScale;
		float3 initialOffset = QMul(_WorldRotation, _InitialParticleOffset[i].xyz) * _GroupScale;

		float3 currentOffsetLo = _ParticlePosition[iLo].xyz - rootPositionLo;
		float3 currentOffsetHi = _ParticlePosition[iHi].xyz - rootPositionHi;

		float3 positionDeltaLo = strandContribLo * (currentOffsetLo - initialOffsetLo);
		float3 positionDeltaHi = strandContribHi * (currentOffsetHi - initialOffsetHi);
		float3 position = rootPosition + initialOffset + lerp(positionDeltaLo, positionDeltaHi, _LODBlendFraction);

		//TODO transition strand to interpolated to avoid pops
		_ParticlePosition[i].xyz = position;
		_ParticleVelocity[i].xyz = DeriveParticleVelocity(i, position);
	}
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KInterpolateNearest(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x + _SolverStrandCount);

	uint strandIndexLo = _LODGuideIndex[(_LODIndexLo * _StrandCount) + strandIndex];

#if LAYOUT_INTERLEAVED
	const uint strandParticleBeginLo = strandIndexLo;
#else
	const uint strandParticleBeginLo = strandIndexLo * _StrandParticleCount;
#endif

	float strandContribLo = _RootScale[strandIndex] / _RootScale[strandIndexLo];

	float3 rootPositionLo = _RootPosition[strandIndexLo].xyz;
	float3 rootPosition = _RootPosition[strandIndex].xyz;

	_ParticlePosition[strandParticleBegin].xyz = rootPosition;
	_ParticleVelocity[strandParticleBegin].xyz = DeriveParticleVelocity(strandParticleBegin, rootPosition);

	for (uint i = strandParticleBegin + strandParticleStride, iLo = strandParticleBeginLo + strandParticleStride; i != strandParticleEnd; i += strandParticleStride, iLo += strandParticleStride)
	{
		float3 initialOffsetLo = QMul(_WorldRotation, _InitialParticleOffset[iLo].xyz) * _GroupScale;
		float3 initialOffset = QMul(_WorldRotation, _InitialParticleOffset[i].xyz) * _GroupScale;

		float3 currentOffsetLo = _ParticlePosition[iLo].xyz - rootPositionLo;

		float3 positionDeltaLo = strandContribLo * (currentOffsetLo - initialOffsetLo);
		float3 position = rootPosition + initialOffset + positionDeltaLo;

		//TODO transition strand to interpolated to avoid pops
		_ParticlePosition[i].xyz = position;
		_ParticleVelocity[i].xyz = DeriveParticleVelocity(i, position);
	}
}

#endif//F_INTERPOLATE

//-----------------
// kernels staging

#if F_STAGING

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KStaging(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	float4 rootFrame = _RootFrame[strandIndex];
	float3 rootDir = QMul(rootFrame, float3(0, 1, 0));

	float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 r0 = rootDir;

	for (uint i = strandParticleBegin; i != strandParticleEnd - strandParticleStride; i += strandParticleStride)
	{
		float3 p1 = _ParticlePosition[i + strandParticleStride].xyz;
		float3 r1 = normalize(p1 - p0);

		StoreStagingPosition(i, p0);
		//_StagingTangent[i].xyz = normalize(r0 + r1);

		p0 = p1;
		r0 = r1;
	}

	StoreStagingPosition(strandParticleEnd - strandParticleStride, p0);
	//_StagingTangent[strandParticleEnd - strandParticleStride].xyz = r0;
}

void CatmullRomPositionTangent(float3 p0, float3 m0, float3 p1, float3 m1, float t, out float3 x0_t, out float3 v0_t)
{
	float tt = t * t;
	float ttt = t * tt;

	x0_t =
		p0 * (2 * ttt - 3 * tt + 1) +
		m0 * (ttt - 2 * tt + t) +
		p1 * (-2 * ttt + 3 * tt) +
		m1 * (ttt - tt);

	v0_t =
		p0 * (6 * tt - 6 * t) +
		m0 * (3 * tt - 4 * t + 1) +
		p1 * (-6 * tt + 6 * t) +
		m1 * (3 * tt - 2 * t);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void KStagingSubdivision(
	uint3 groupIdx : SV_GroupID,
	uint3 localIdx : SV_GroupThreadID,
	uint3 worldIdx : SV_DispatchThreadID,
	uint threadIdx : SV_GroupIndex)
	// SV_GroupID           execution group coords
	// SV_GroupThreadID     thread coords within execution group
	// SV_DispatchThreadID  thread coords (global)
	// SV_GroupIndex        thread offset within execution group
{
	DECLARE_STRAND(worldIdx.x);

	float4 rootFrame = _RootFrame[strandIndex];
	float3 rootVec = GetParticleInterval(strandIndex) * QMul(rootFrame, float3(0, 1, 0));

	float3 p0 = _ParticlePosition[strandParticleBegin].xyz;
	float3 p1 = _ParticlePosition[strandParticleBegin + strandParticleStride].xyz;
	float3 m0 = lerp(rootVec, p1 - p0, 0.75);

	const uint segmentStepCount = _StagingSubdivision + 1;
	const float segmentStep = 1.0 / segmentStepCount;

#if LAYOUT_INTERLEAVED
	uint writeIndex = strandIndex;
	uint writeStride = _StrandCount;
#else
	uint writeIndex = strandIndex * _StagingVertexCount;
	uint writeStride = 1;
#endif

	// segment 1..N-1
	for (uint i = strandParticleBegin + strandParticleStride; i != strandParticleEnd - strandParticleStride; i += strandParticleStride)
	{
		float3 p2 = _ParticlePosition[i + strandParticleStride].xyz;
		float3 m1 = 0.5 * (p2 - p0);

		for (uint k = 0; k != segmentStepCount; k++, writeIndex += writeStride)
		{
			float3 x0_t;
			float3 v0_t;

			CatmullRomPositionTangent(p0, m0, p1, m1, segmentStep * k, x0_t, v0_t);

			StoreStagingPosition(writeIndex, x0_t);
			//_StagingTangent[writeIndex].xyz = v0_t;
		}

		p0 = p1;
		p1 = p2;
		m0 = m1;
	}

	// segment N
	{
		float3 m1 = lerp(m0, p1 - p0, 2.0);

		for (uint k = 0; k != segmentStepCount; k++, writeIndex += writeStride)
		{
			float3 x0_t;
			float3 v0_t;

			CatmullRomPositionTangent(p0, m0, p1, m1, segmentStep * k, x0_t, v0_t);

			StoreStagingPosition(writeIndex, x0_t);
			//_StagingTangent[writeIndex].xyz = v0_t;
		}

		p0 = p1;
		m0 = m1;
	}

	// cap
	StoreStagingPosition(writeIndex, p0);
	//_StagingTangent[writeIndex].xyz = m0;
}

#endif//F_STAGING
